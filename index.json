[{"categories":null,"contents":"将hugo创建的博客使用GitHub Pages发布网站 指定Repository name为 \u0026lt;your_github_username\u0026gt;.github.io 这是必须，不然GitHub Pages没有办法运行你的博客页面。\n接下来在创建gh-pages分支：\n​\t首先告诉你为什么要创建gh-pages分支\n由于我们需要将hugo创建的博客根目录发布到main分支上，但是该目录Github Pages是没办法直接将该部分内容发布到\u0026lt;your_github_username\u0026gt;.github.io网站上去的。只有该目录下的public才能让Github Pages识别到你的网站上。 当然也可以直接将public目录上传到main分支上，不创建gh-pages分支，但是这么做有一个缺点就是，你网站的根目录配置文件，主题文件等内容都没有托管到Github上，你只能依赖你本地的项目去发布文章，修改网页，如果你换了 最重要的是配置文件主题等内容与发布内容分离，main分支主要是hugo以及文章主题的内容，而gh-pages分支就是保存hugo根据你的配置数据等内容产生的静态文件。 ​\t设备，就没办法发布文章了。所以这也是为什么要再创建一个gh-pages分支，该分支主要保存根目录下内容，并且将public的内容也放到根目录，这样每次提交main的时候，让Github Pages 安装hugo以及主题需要的资源，然后生成public目录就行了。\n创建gh-pages分支\n# 创建gh-pages分支 git checkout -b gh-pages #这块最好是在项目搭建最开始，这样我们的gh-pages分支是干净的什么都没有，如果根目录已经有文件了 也没事直接add即可 git add . git commit -m \u0026#34;添加分支\u0026#34; #将当前根目录push到Github上面 git push -u origin gh-pages 创建自动化部署文件\n在根目录创建.github目录，在.github目录创建workflows目录，在workflows目录下创建deploy.yml文件\n然后将下方内容复制到你的deploy.ymml文件中\nname: Deploy to Github Pages # run when a commit is pushed to \u0026#34;source\u0026#34; branch on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: # checkout to the commit that has been pushed - uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Update Hugo Modules run: hugo mod tidy - name: Setup Node uses: actions/setup-node@v4 with: node-version: 20 - name: Install node modules run: | hugo mod npm pack npm install - name: Build run: hugo --minify # push the generated content into the `gh-pages` branch. - name: Deploy uses: peaceiris/actions-gh-pages@v4 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: gh-pages publish_dir: ./public 然后将该目录上传到你的main分支下。\ngit add . git commit -m \u0026#34;添加自动化部署文件\u0026#34; git push -u origin main 然后配置Github Action权限\n之后直接修改任意文件，然后上传到你的main分支下，然后打开action，查看是否正在部署。\n如果出现部署失败，不要慌，直接点击进去，看哪里出现问题了，然后直接复制到ai下面，问一下。现在ai能解决你大部分问题。\n到这里就部署完成了，然后就是根据不同主题，修改相应的配置优化网站了~~~~~\n","date":"2026年01月12日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/posts/deploy-hugo-blog/deploy-to-github/","summary":"\u003ch1 id=\"将hugo创建的博客使用github-pages发布网站\"\u003e将hugo创建的博客使用GitHub Pages发布网站\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/deploy-to-github/image-20260112045208111.png\" alt=\"image-20260112045208111\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cfont color=\"  #BA55D3\"\u003e\u003cb\u003e指定Repository name为 \u0026lt;your_github_username\u0026gt;.github.io\u003c/b\u003e\u003c/font\u003e 这是必须，不然GitHub Pages没有办法运行你的博客页面。\u003c/p\u003e\n\u003cp\u003e接下来在创建gh-pages分支：\u003c/p\u003e\n\u003cp\u003e​\t首先告诉你为什么要创建gh-pages分支\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e由于我们需要将hugo创建的博客根目录发布到main分支上，但是该目录Github Pages是没办法直接将该部分内容发布到\u0026lt;your_github_username\u0026gt;.github.io网站上去的。只有该目录下的public才能让Github Pages识别到你的网站上。\u003c/li\u003e\n\u003cli\u003e当然也可以直接将public目录上传到main分支上，不创建gh-pages分支，但是这么做有一个缺点就是，你网站的根目录配置文件，主题文件等内容都没有托管到Github上，你只能依赖你本地的项目去发布文章，修改网页，如果你换了\u003c/li\u003e\n\u003cli\u003e最重要的是配置文件主题等内容与发布内容分离，main分支主要是hugo以及文章主题的内容，而gh-pages分支就是保存hugo根据你的配置数据等内容产生的静态文件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e​\t设备，就没办法发布文章了。所以这也是为什么要再创建一个gh-pages分支，该分支主要保存根目录下内容，并且将public的内容也放到根目录，这样每次提交main的时候，让Github Pages 安装hugo以及主题需要的资源，然后生成public目录就行了。\u003c/p\u003e\n\u003cp\u003e创建gh-pages分支\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-she\" data-lang=\"she\"\u003e# 创建gh-pages分支\n git checkout -b gh-pages\n \n #这块最好是在项目搭建最开始，这样我们的gh-pages分支是干净的什么都没有，如果根目录已经有文件了 也没事直接add即可\n git add .\n git commit -m \u0026#34;添加分支\u0026#34;\n \n#将当前根目录push到Github上面\ngit push -u origin gh-pages\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e创建自动化部署文件\u003c/p\u003e\n\u003cp\u003e\u003cfont color=\"  #BA55D3\"\u003e\u003cb\u003e在根目录创建.github目录，在.github目录创建workflows目录，在workflows目录下创建deploy.yml文件\u003c/b\u003e\u003c/font\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/deploy-to-github/image-20260112061547254.png\" alt=\"image-20260112061547254\"\u003e\u003c/p\u003e\n\u003cp\u003e然后将下方内容复制到你的deploy.ymml文件中\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yml\" data-lang=\"yml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eDeploy to Github Pages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# run when a commit is pushed to \u0026#34;source\u0026#34; branch\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eon\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003epush\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003ebranches\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    - \u003cspan style=\"color:#ae81ff\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003ejobs\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003edeploy\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003eruns-on\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eubuntu-latest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003esteps\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e# checkout to the commit that has been pushed\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    - \u003cspan style=\"color:#f92672\"\u003euses\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eactions/checkout@v4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eSetup Hugo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003euses\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003epeaceiris/actions-hugo@v3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003ewith\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003ehugo-version\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;latest\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003eextended\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eUpdate Hugo Modules\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003erun\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ehugo mod tidy\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eSetup Node\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003euses\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eactions/setup-node@v4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003ewith\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003enode-version\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e20\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eInstall node modules\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003erun\u003c/span\u003e: |\u003cspan style=\"color:#e6db74\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e        hugo mod npm pack\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e        npm install\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eBuild\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003erun\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ehugo --minify\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e# push the generated content into the `gh-pages` branch.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    - \u003cspan style=\"color:#f92672\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003eDeploy\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003euses\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003epeaceiris/actions-gh-pages@v4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003ewith\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003egithub_token\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e${{ secrets.GITHUB_TOKEN }}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003epublish_branch\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003egh-pages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#f92672\"\u003epublish_dir\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e./public\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后将该目录上传到你的main分支下。\u003c/p\u003e","tags":null,"title":"Deploy to Github"},{"categories":null,"contents":"hugo安装主题 在安装主题之前，你需要下载git,node.js\n接下来有关主题的安装，以及发布到Github Pages上都是默认安装了git、node.js。\n选择主题 当我们成功创建了我们的博客网站，接下来就是选择一个你喜欢的主题。\n可以从hugo官方网站https://themes.gohugo.io/上选择主题，也可以从搜索引擎上搜“hugo 主题”找到一款你中意的主题。\n接下来我们都是以hugo官网上推荐的toha主题作为例子来讲解如何安装主题，并且发布到Github Pages上。\n安装toha 我们打开https://themes.gohugo.io/\n选择toha主题\n点击demo\n查看toha官方文档\n选择Quickstart跟着做即可\n这里需要注意的是，如果你希望你的blog项目托管到Github Pages上，建议在安装主题之前，先创建好GitHub Repository。\n然后将Repository name设置为\u0026lt;your_github_name\u0026gt;.github.io格式。\n之后点击创建即可，然后将你创建好website项目的根目录 下执行下面的命令：\ngit add . git commit -m \u0026#34;初始化项目\u0026#34; git branch -M main git remote add origin git@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_username\u0026gt;.github.com.git git push -u origin main 安装toha theme有两种安装方法，这里只介绍其中一个：\n直接下载主题到/themes/目录下\ngit clone https://github.com/hugo-themes/toha ./themes/ 查看目录是否存在toha\n如果存在接下来就是执行下面的命令：\nhugo mod init github.com/\u0026lt;your user name\u0026gt;/\u0026lt;your repo name\u0026gt; 然后修改hugo.yaml 配置文件：\n如果执行使用hugo new web-site命令，其默认的配置文件是tmol文件，所以我们先将该文件名改为hugo.tmol.backup。然后创建一个名为hugo.yaml文件。并且将下面的内容复制到hugo.yaml文件中\nbaseURL: https://foreverool.github.io/ # 这里需要填写你自己的github 上的repository 名称 languageCode: zh-cn title: \u0026#34;foreverool\u0026#39;s blog\u0026#34; timeZone: \u0026#34;Asia/Shanghai\u0026#34; # 中国标准时间（UTC+8），解决时间显示偏移问题 theme: \u0026#34;toha\u0026#34; defaultContentLanguage: zh-cn module: mounts: - source: ./node_modules/flag-icon-css/flags target: static/flags - source: ./node_modules/@fontsource/mulish/files target: static/files - source: ./node_modules/katex/dist/fonts target: static/fonts 做完上面的操作，接下来执行关键步骤：\n# download the theme hugo mod get -u # download the theme\u0026#39;s dependencies hugo mod tidy # generate node dependencies hugo mod npm pack # install install dependencies npm install 执行完这些，你的项目目录下会有node_modules目录。如果没有重新执行上述命令。\n接下来执行hugo server -w命令 看是否能正常运行，如果不能，记得安装hugo extended 。\n到这里目前主题已经安装完成了，其他有关主题的详细配置，toha官方写会更加详细，如果英文阅读能力稍微差点的，可以直接右键选择翻译该网站即可。\n","date":"2026年01月11日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/posts/deploy-hugo-blog/install-theme/","summary":"\u003ch1 id=\"hugo安装主题\"\u003ehugo安装主题\u003c/h1\u003e\n\u003cp\u003e在安装主题之前，你需要下载\u003ccode\u003egit\u003c/code\u003e,\u003ccode\u003enode.js\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e接下来有关主题的安装，以及发布到Github Pages上都是默认安装了git、node.js。\u003c/p\u003e\n\u003ch2 id=\"选择主题\"\u003e选择主题\u003c/h2\u003e\n\u003cp\u003e当我们成功创建了我们的博客网站，接下来就是选择一个你喜欢的主题。\u003c/p\u003e\n\u003cp\u003e可以从\u003ccode\u003ehugo\u003c/code\u003e官方网站https://themes.gohugo.io/上选择主题，也可以从搜索引擎上搜“hugo 主题”找到一款你中意的主题。\u003c/p\u003e\n\u003cp\u003e接下来我们都是以\u003ccode\u003ehugo\u003c/code\u003e官网上推荐的\u003ccode\u003etoha\u003c/code\u003e主题作为例子来讲解如何安装主题，并且发布到Github Pages上。\u003c/p\u003e\n\u003ch2 id=\"安装toha\"\u003e安装toha\u003c/h2\u003e\n\u003cp\u003e我们打开https://themes.gohugo.io/\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install-theme/image-20260111205655685.png\" alt=\"image-20260111205655685\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cfont color=\"  #FFA500\"\u003e\u003cb\u003e选择toha主题\u003c/b\u003e\u003c/font\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install-theme/image-20260111210157774.png\" alt=\"image-20260111210157774\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cfont color=\"  #FFA500\"\u003e\u003cb\u003e点击\u003cstrong\u003edemo\u003c/strong\u003e\u003c/b\u003e\u003c/font\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install-theme/image-20260111210235461.png\" alt=\"image-20260111210235461\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cfont color=\"  #FFA500\"\u003e\u003cb\u003e查看toha官方文档\u003c/b\u003e\u003c/font\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install-theme/image-20260111210305683.png\" alt=\"image-20260111210305683\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install-theme/image-20260111210435708.png\" alt=\"image-20260111210435708\"\u003e\u003c/p\u003e\n\u003cp\u003e选择Quickstart跟着做即可\u003c/p\u003e\n\u003cp\u003e这里需要注意的是，如果你希望你的blog项目托管到Github Pages上，建议在安装主题之前，先创建好GitHub Repository。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install-theme/image-20260111211221363.png\" alt=\"image-20260111211221363\"\u003e\u003c/p\u003e\n\u003cp\u003e然后\u003cstrong\u003e将Repository name设置为\u0026lt;your_github_name\u0026gt;.github.io\u003c/strong\u003e格式。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install-theme/image-20260111211335175.png\" alt=\"image-20260111211335175\"\u003e\u003c/p\u003e\n\u003cp\u003e之后点击创建即可，然后将你创建好website项目的根目录 下执行下面的命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit add .\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit commit -m \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;初始化项目\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit branch -M main \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit remote add origin git@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_username\u0026gt;.github.com.git\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit push -u origin main\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e安装toha theme有两种安装方法，这里只介绍其中一个：\u003c/p\u003e\n\u003cp\u003e直接下载主题到/themes/目录下\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egit clone  https://github.com/hugo-themes/toha ./themes/\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e查看目录是否存在toha\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install-theme/image-20260111212213717.png\" alt=\"image-20260111212213717\"\u003e\u003c/p\u003e\n\u003cp\u003e如果存在接下来就是执行下面的命令：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehugo mod init github.com/\u0026lt;your user name\u0026gt;/\u0026lt;your repo name\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后修改hugo.yaml 配置文件：\u003c/p\u003e","tags":null,"title":"Install Theme"},{"categories":null,"contents":"hugo个人博客搭建 在使用hugo搭建个人博客之前，我们需要明确知道hugo是一种生成静态文件的博客软件。它没有与数据库这种存储用户数据的软件进行搭配，而是将我们的文章转换成静态网页的形式发布的。\n该篇文章所有的安装过程都是在windows上\n1. 下载与安装hugo 1.1 下载 如果你使用了其它系统，可以参考hugo官网https://gohugo.io/installation\n在windows下安装hugo个人建议直接在https://github.com/gohugoio/hugo/releases/tag/v0.154.4下载安装包，这里要注意官方提供了很多不同的压缩包，建议安装扩展版也就是安装包中包含extended，这里主要是方便你后续选择不同的hugo主题的时候可以正常使用这些主题。extended就是hugo的扩展，包含了更多的内容。\n1.2 安装 这个安装步骤其实准确来说是将下载好的压缩包解压，解压完成后，你会得到hugo.exe软件，然后将该软件所在的目录添加到用户的环境变量中，这样就可以直接在命令行中使用hugo。\n对于不知道如何设置环境变量的同学，请看接下来的操作，如果知道的同学直接看第二部分。\n设置环境变量\nwindows 11\n打开设置，找到系统\n然后点击系统，拉到最下面，找到系统信息，并且点击\n然后找到高级系统设置\n之后点击环境变量\n在用户那里找到path\n双击path，然后将hugo所在的目录复制到path那里就可以了\n之后打开cmd看是否可以执行hugo，如果不能执行直接重启，然后就可以了。\n这也是有时候我们设置完环境变量不能立马直接某些程序的解决方法之一。\n2. 创建网站（博客） 如果在命令行可以正常使用hugo ，那么执行下面的命令:\nhugo new site your-website-name 这个命令主要是创建你的网站的骨架，此时还没有任何网站主题和相关内容。\n在创建完网站骨架之后，你可以在命令行切换到your-website-name目录下，然后执行：\n# 切换到刚才使用hugo创建的项目根目录下 Z:\\blog\u0026gt;cd demo-website #然后执行 hugo server -D 如果出现下面这样的内容，就证明你的网站骨架创建成功了，接下来就是选择主题了\n之后想要查看你的网站内容的话，按住ctrl 并且点击上面的localhost地址就可以直接访问\n此时下载与安装基本已经完成了，接下来就是配置主题了。请看下一篇文章~\n","date":"2026年01月11日","hero":"/images/posts/deploy-hugo-blog/images.png","permalink":"https://foreverool.github.io/posts/deploy-hugo-blog/install/","summary":"\u003ch1 id=\"hugo个人博客搭建\"\u003ehugo个人博客搭建\u003c/h1\u003e\n\u003cp\u003e在使用hugo搭建个人博客之前，我们需要明确知道hugo是一种生成静态文件的博客软件。它没有与数据库这种存储用户数据的软件进行搭配，而是将我们的文章转换成静态网页的形式发布的。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e该篇文章所有的安装过程都是在windows上\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"1-下载与安装hugo\"\u003e1. 下载与安装hugo\u003c/h2\u003e\n\u003ch3 id=\"11-下载\"\u003e1.1 下载\u003c/h3\u003e\n\u003cp\u003e如果你使用了其它系统，可以参考\u003ccode\u003ehugo\u003c/code\u003e官网\u003ca href=\"https://gohugo.io/installation\" target=\"_blank\" rel=\"noopener\"\u003ehttps://gohugo.io/installation\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e在windows下安装hugo个人建议直接在https://github.com/gohugoio/hugo/releases/tag/v0.154.4下载安装包，这里要注意官方提供了很多不同的压缩包，\u003cstrong\u003e建议安装扩展版也就是安装包中包含extended\u003c/strong\u003e，这里主要是方便你后续选择不同的hugo主题的时候可以正常使用这些主题。extended就是hugo的扩展，包含了更多的内容。\u003c/p\u003e\n\u003ch3 id=\"12-安装\"\u003e1.2 安装\u003c/h3\u003e\n\u003cp\u003e这个安装步骤其实准确来说是将下载好的压缩包解压，解压完成后，你会得到\u003ccode\u003ehugo.exe\u003c/code\u003e软件，然后将该软件所在的目录添加到用户的环境变量中，这样就可以直接在命令行中使用\u003ccode\u003ehugo\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e对于不知道如何设置环境变量的同学，请看接下来的操作，如果知道的同学直接看第二部分。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e设置环境变量\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ewindows 11\u003c/p\u003e\n\u003cp\u003e打开设置，找到系统\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install/image.png\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e然后\u003cstrong\u003e点击系统\u003c/strong\u003e，拉到最下面，\u003cstrong\u003e找到系统信息\u003c/strong\u003e，并且点击\u003c/p\u003e\n\u003cp\u003e然后找到\u003cstrong\u003e高级系统设置\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install/image%201.png\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e之后点击环境变量\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install/image%202.png\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在用户那里找到path\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install/image%203.png\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e双击path，然后将hugo所在的目录复制到path那里就可以了\u003c/p\u003e\n\u003cp\u003e之后打开cmd看是否可以执行hugo，如果不能执行直接重启，然后就可以了。\u003c/p\u003e\n\u003cp\u003e这也是有时候我们设置完环境变量不能立马直接某些程序的解决方法之一。\u003c/p\u003e\n\u003ch2 id=\"2-创建网站博客\"\u003e2. 创建网站（博客）\u003c/h2\u003e\n\u003cp\u003e如果在命令行可以正常使用\u003ccode\u003ehugo\u003c/code\u003e ，那么执行下面的命令:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehugo new site your-website-name\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个命令主要是创建你的网站的骨架，此时还没有任何网站主题和相关内容。\u003c/p\u003e\n\u003cp\u003e在创建完网站骨架之后，你可以在命令行切换到your-website-name目录下，然后执行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 切换到刚才使用hugo创建的项目根目录下\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eZ:\u003cspan style=\"color:#ae81ff\"\u003e\\b\u003c/span\u003elog\u0026gt;cd demo-website\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#然后执行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehugo server -D\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果出现下面这样的内容，就证明你的网站骨架创建成功了，接下来就是选择主题了\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install/image%204.png\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e之后想要查看你的网站内容的话，按住ctrl 并且点击上面的localhost地址就可以直接访问\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/install/image%205.png\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此时下载与安装基本已经完成了，接下来就是配置主题了。请看下一篇文章~\u003c/p\u003e","tags":null,"title":"下载安装hugo"},{"categories":null,"contents":"chan的实现原理 0. 预备知识 0.1 Unix管道 ​\t在Unix以及类Unix操作系统中，管道(pipeline)是将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入，也就是说管道其实是进程间的通信机制。\n​\t管道的典型用途是为两个不同进程（一个父进程，另一个是子进程）间进行通信的手段。首先会根据父进程fork（unix创建子进程的函数）一个子进程（也就是创建一个父进程的副本），由于创建管道会返回两个文件描述符，一个是读描述符，另一个是写描述符。在进行fork的时候，进程空间会进行复制，也就是说该文件描述符也会被复制，所有两个进程都有相同的读写文件描述符。\n​\t当父进程关闭读出端，子进程关闭同一管道的写入端。这样就在父子进程间提供了一个单向数据流。\n​\t比如在执行linux命令时：\nls -l | grep \u0026#34;chan\u0026#34; ​\t首先父进程就是shell，它首先会创建管道(pipe)，\n接着创建ls 子进程，之后创建grep子进程，也就是fork两个子进程，这样两个子进程就会包含管道返回的两个文件描述符，之后将ls -l所执行的命令标准输出写入到管道之中，然后grep \u0026quot;chan\u0026quot;则会从管道读取数据并处理，最后就是返回结果。\n0.1.1 管道在linux下的具体实现 ​\t管道在Linux系统具体实现是缓冲区buffer而不是队列。\n​\t管道会为读端和写端分别分配内核缓冲区， 写进程将数据写入写端缓冲区，读进程从读端缓冲区读取数据。内核将写端缓冲区的数据进行复制到读端缓冲区，然后内核也会维护读写两端的位置指针。\n​\t同步机制：\n​\t当写端缓冲区满的时候，写进程会被阻塞掉，直到读进程读取了部分数据腾出空间。\n​\t当读缓冲区为空的时候，读进程会被阻塞，直到写进程写入了新数据。\n​\t管道的数据采用FIFO的数据处理模式，也就是先写入的数据先被读取。\n1. chanel ​\t在go语言中，一个进程可能会有多个goroutine，多个goroutine之间的通信可以使用chanel或者对于共享内存进行加锁。\n1.1 chan的数据结构 ​\t在go SDK 1.20.3 中的runtime/chan.gp文件中就定义了chan的底层数据结构hchan。\ntype hchan struct{ qcount uint // 表示当前队列中的剩余元素 dataqsiz uint\t// 表示循环队列的大小，即可以存放元素的个数 buf unsafe.Pointer\t// 指向一个dataqsiz大小的数组，也就是环形队列的指针 elemsize uint16\t// 每个元素的大小 closed uint32\t// 标记关闭状态 elemtype *_type\t// 元素类型 sendx uint\t// 队列下标，指元素写入时存放到队列中的位置 recvx uint\t// 队列下标，指元素从队列的该位置读出 recvq waitq\t// 等待读消息的goroutine队列 sendq waitq\t// 等待写消息的goroutine队列 lcok mutex\t// 互斥锁，chan不允许并发读写 } type waitq struct { first *sudog last *sudog } ​\twaitg类型是一个队列，其包含队列的第一个元素指针和最后一个元素指针。\n​\twaitq实现了两个方法分别是: enqueue, dequeue。\ntype sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack) // The following fields are never accessed concurrently. // For channels, waitlink is only accessed by g. // For semaphores, all fields (including the ones above) // are only accessed when holding a semaRoot lock. acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so // g.selectDone must be CAS\u0026#39;d to win the wake-up race. isSelect bool // success indicates whether communication over channel c // succeeded. It is true if the goroutine was awoken because a // value was delivered over channel c, and false if awoken // because c was closed. success bool parent *sudog // semaRoot binary tree waitlink *sudog // g.waiting list or semaRoot waittail *sudog // semaRoot c *hchan // channel } sudog:用于表示一个在等待列表的g(表示goroutine 的数据结构)。\n思考： 为什么需要sudog而不是直接使用g？\n​\tgo SDK中作者表示：\n// sudog is necessary because the g ↔ synchronization object relation // is many-to-many. A g can be on many wait lists, so there may be // many sudogs for one g; and many gs may be waiting on the same // synchronization object, so there may be many sudogs for one object. ​\t总结：sudog的存在是必须的，因为goroutine和同步对象之间的关系是多对多的。一个goroutine可以在多个等待列表当中，因此多个sudog表示同一个goroutine，并且多个goroutine可能等待同一个同步对象，所以有个同步对象有多个sudog。\n1.1.1 环形队列 ​\tchan内部实现了一个环形队列的缓冲区，也就是buf字段，队列的长度是在创建chan的时候指定，也就是使用make函数创建的时候指定的，如果不指定长度，则没有这个环形缓冲区，也就是无缓冲chan。\n1.1.2 等待队列 ​\t一个goroutine从chanel读数据，如果chanel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。\n​\t一个goroutine从chanel写数据，如果chanel缓冲区满了或者没有缓冲区，当前goroutine会被阻塞。\n​\t被阻塞的goroutine会被存储在等待队列当中，也就是recvq， sendq当中。\n​\tsendq队列用于存储那些试图向chanel发送数据但被阻塞的goroutine。\n​\trecvq队列用于存储那些试图向chanel读取数据但被阻塞的goroutine。\n思考： 当多个读goroutine被阻塞，然后存储在recvq等待队列当中，此时有一个写goroutine写入数据，那么唤醒所有等待队列的goroutine还是唤醒部分？\n​\t答: chanel不会唤醒所有等待队列的goroutine，会取出一个goroutine处理数据，因为chanel的设计是尽可能高效地完成数据的传递，如果每次读取都唤醒所有的recvq中的goroutine会导致大量无谓的上下文切换，降低性能。选择队列头部的goroutine来传输数据，可以保证FIFO的顺序，避免饥饿问题的发生。\n1.1.3 类型信息 ​\t一个chanel只能传递一种类型的值，类型信息存储在hchan当中【elemtype. elemsize】\n1.1.4 锁 ​\t一个chanel同时仅允许被一个goroutine读写。这也是为什么chanel是线程安全的数据类型。\n1.2 向chanel中写数据 code\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { if !block { return false } gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } if debugChan { print(\u0026#34;chansend: chan=\u0026#34;, c, \u0026#34;\\n\u0026#34;) } if raceenabled { racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend)) } // Fast path: check for failed non-blocking operation without acquiring the lock. // // After observing that the channel is not closed, we observe that the channel is // not ready for sending. Each of these observations is a single word-sized read // (first c.closed and second full()). // Because a closed channel cannot transition from \u0026#39;ready for sending\u0026#39; to // \u0026#39;not ready for sending\u0026#39;, even if the channel is closed between the two observations, // they imply a moment between the two when the channel was both not yet closed // and not ready for sending. We behave as if we observed the channel at that moment, // and report that the send cannot proceed. // // It is okay if the reads are reordered here: if we observe that the channel is not // ready for sending and then observe that it is not closed, that implies that the // channel wasn\u0026#39;t closed during the first observation. However, nothing here // guarantees forward progress. We rely on the side effects of lock release in // chanrecv() and closechan() to update this thread\u0026#39;s view of c.closed and full(). if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { return false } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } if sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } if c.qcount \u0026lt; c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. qp := chanbuf(c, c.sendx) if raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ unlock(\u0026amp;c.lock) return true } if !block { unlock(\u0026amp;c.lock) return false } // Block on the channel. Some receiver will complete our operation for us. gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we\u0026#39;re about // to park on a channel. The window between when this G\u0026#39;s status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. gp.parkingOnChan.Store(true) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) // Ensure the value being sent is kept alive until the // receiver copies it out. The sudog has a pointer to the // stack object, but sudogs aren\u0026#39;t considered as roots of the // stack tracer. KeepAlive(ep) // someone woke us up. if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) if closed { if c.closed == 0 { throw(\u0026#34;chansend: spurious wakeup\u0026#34;) } panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } return true } 向一个chanel写入数据的具体实现过程：\n检查chanel的状态\n首先检查chanel的状态，包括是否已关闭、是否缓冲区满了。\n尝试直接发送\n如果chanel不满且有等待接收的goroutine，则会直接将数据发送给等待的goroutine，并唤醒该goroutine。\n如何发送数据\nif sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } 根据源码我们可以看出如果recvq等待队列中有读goroutine（不为空的情况下），从该队列出队获取到一个goroutine然后发送数据。由于recvq不为空，也就是说chanel中的buf环形队列中没有数据，此时就直接发送数据就可以了。\n// send processes a send operation on an empty channel c. // The value ep sent by the sender is copied to the receiver sg. // The receiver is then woken up to go on its merry way. // Channel c must be empty and locked. send unlocks c with unlockf. // sg must already be dequeued from c. // ep must be non-nil and point to the heap or the caller\u0026#39;s stack. func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if raceenabled { if c.dataqsiz == 0 { racesync(c, sg) } else { // Pretend we go through the buffer, even though // we copy directly. Note that we need to increment // the head/tail locations only when raceenabled. racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } } if sg.elem != nil { sendDirect(c.elemtype, sg, ep) sg.elem = nil } gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) { // src is on our stack, dst is a slot on another stack. // Once we read sg.elem out of sg, it will no longer // be updated if the destination\u0026#39;s stack gets copied (shrunk). // So make sure that no preemption points can happen between read \u0026amp; use. dst := sg.elem typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size) // No need for cgo write barrier checks because dst is always // Go memory. memmove(dst, src, t.size) } 未完待续\u0026hellip;.\n","date":"2026年01月10日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/posts/golang/chanel-base/","summary":"\u003ch1 id=\"chan的实现原理\"\u003echan的实现原理\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"0-预备知识\"\u003e0. 预备知识\u003c/h1\u003e\n\u003ch3 id=\"01-unix管道\"\u003e0.1 Unix管道\u003c/h3\u003e\n\u003cp\u003e​\t在\u003ccode\u003eUnix\u003c/code\u003e以及类\u003ccode\u003eUnix\u003c/code\u003e操作系统中，管道(pipeline)是将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入，也就是说管道其实是进程间的通信机制。\u003c/p\u003e\n\u003cp\u003e​\t管道的典型用途是为两个不同进程（一个父进程，另一个是子进程）间进行通信的手段。首先会根据父进程\u003ccode\u003efork\u003c/code\u003e（\u003ccode\u003eunix\u003c/code\u003e创建子进程的函数）一个子进程（也就是创建一个父进程的副本），由于创建管道会返回两个文件描述符，一个是读描述符，另一个是写描述符。在进行\u003ccode\u003efork\u003c/code\u003e的时候，进程空间会进行复制，也就是说该文件描述符也会被复制，所有两个进程都有相同的读写文件描述符。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/golang/chanel_base/Image00027.jpg\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t当父进程关闭读出端，子进程关闭同一管道的写入端。这样就在父子进程间提供了一个单向数据流。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/golang/chanel_base/Image00028.jpg\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e​\t比如在执行\u003ccode\u003elinux\u003c/code\u003e命令时：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003els -l | grep \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;chan\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e​\t首先父进程就是\u003ccode\u003eshell\u003c/code\u003e，它首先会创建管道(pipe)，\u003c/p\u003e\n\u003cp\u003e接着创建\u003ccode\u003els \u003c/code\u003e子进程，之后创建\u003ccode\u003egrep\u003c/code\u003e子进程，也就是\u003ccode\u003efork\u003c/code\u003e两个子进程，这样两个子进程就会包含管道返回的两个文件描述符，之后将\u003ccode\u003els -l\u003c/code\u003e所执行的命令标准输出写入到管道之中，然后\u003ccode\u003egrep \u0026quot;chan\u0026quot;\u003c/code\u003e则会从管道读取数据并处理，最后就是返回结果。\u003c/p\u003e\n\u003ch4 id=\"011-管道在linux下的具体实现\"\u003e0.1.1 管道在linux下的具体实现\u003c/h4\u003e\n\u003cp\u003e​\t管道在\u003ccode\u003eLinux\u003c/code\u003e系统具体实现是缓冲区\u003ccode\u003ebuffer\u003c/code\u003e而不是队列。\u003c/p\u003e\n\u003cp\u003e​\t管道会为读端和写端分别分配内核缓冲区， 写进程将数据写入写端缓冲区，读进程从读端缓冲区读取数据。内核将写端缓冲区的数据进行复制到读端缓冲区，然后内核也会维护读写两端的位置指针。\u003c/p\u003e\n\u003cp\u003e​\t同步机制：\u003c/p\u003e\n\u003cp\u003e​\t\t\t\t\t当写端缓冲区满的时候，写进程会被阻塞掉，直到读进程读取了部分数据腾出空间。\u003c/p\u003e\n\u003cp\u003e​\t\t\t\t\t当读缓冲区为空的时候，读进程会被阻塞，直到写进程写入了新数据。\u003c/p\u003e\n\u003cp\u003e​\t管道的数据采用\u003ccode\u003eFIFO\u003c/code\u003e的数据处理模式，也就是先写入的数据先被读取。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-chanel\"\u003e1. chanel\u003c/h2\u003e\n\u003cp\u003e​\t在\u003ccode\u003ego\u003c/code\u003e语言中，一个进程可能会有多个\u003ccode\u003egoroutine\u003c/code\u003e，多个\u003ccode\u003egoroutine\u003c/code\u003e之间的通信可以使用\u003ccode\u003echanel\u003c/code\u003e或者对于共享内存进行加锁。\u003c/p\u003e\n\u003ch3 id=\"11-chan的数据结构\"\u003e1.1 chan的数据结构\u003c/h3\u003e\n\u003cp\u003e​\t在\u003ccode\u003ego SDK 1.20.3 \u003c/code\u003e中的\u003ccode\u003eruntime/chan.gp\u003c/code\u003e文件中就定义了\u003ccode\u003echan\u003c/code\u003e的底层数据结构\u003ccode\u003ehchan\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ehchan\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003eqcount\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint\u003c/span\u003e \t\t\u003cspan style=\"color:#75715e\"\u003e// 表示当前队列中的剩余元素\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003edataqsiz\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint\u003c/span\u003e\t\t\u003cspan style=\"color:#75715e\"\u003e// 表示循环队列的大小，即可以存放元素的个数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003ebuf\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eunsafe\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePointer\u003c/span\u003e\t\u003cspan style=\"color:#75715e\"\u003e// 指向一个dataqsiz大小的数组，也就是环形队列的指针\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003eelemsize\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint16\u003c/span\u003e\t\t\u003cspan style=\"color:#75715e\"\u003e// 每个元素的大小\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003eclosed\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint32\u003c/span\u003e\t\t\u003cspan style=\"color:#75715e\"\u003e// 标记关闭状态\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003eelemtype\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003e_type\u003c/span\u003e\t\t\u003cspan style=\"color:#75715e\"\u003e// 元素类型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003esendx\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint\u003c/span\u003e\t\t\t\u003cspan style=\"color:#75715e\"\u003e// 队列下标，指元素写入时存放到队列中的位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003erecvx\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint\u003c/span\u003e\t\t\t\u003cspan style=\"color:#75715e\"\u003e// 队列下标，指元素从队列的该位置读出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003erecvq\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ewaitq\u003c/span\u003e\t\t\t\u003cspan style=\"color:#75715e\"\u003e// 等待读消息的goroutine队列\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003esendq\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ewaitq\u003c/span\u003e\t\t\t\u003cspan style=\"color:#75715e\"\u003e// 等待写消息的goroutine队列\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#a6e22e\"\u003elcok\u003c/span\u003e  \u003cspan style=\"color:#a6e22e\"\u003emutex\u003c/span\u003e\t\t\t\u003cspan style=\"color:#75715e\"\u003e// 互斥锁，chan不允许并发读写\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ewaitq\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003efirst\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003esudog\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003elast\u003c/span\u003e  \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003esudog\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e​\t\u003ccode\u003ewaitg\u003c/code\u003e类型是一个队列，其包含队列的第一个元素指针和最后一个元素指针。\u003c/p\u003e","tags":null,"title":"Chanel Base"}]