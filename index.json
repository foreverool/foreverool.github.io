[{"categories":null,"contents":" Unintended Variable Shadowing Uintended Variable Shadowing中文翻译过来是：非预期变量遮蔽\n在讲解什么是非预期变量遮蔽前需要知道什么是变量遮蔽。\n变量遮蔽： 当内层作用域中定义了一个与外层变量同名的变量，此时在内层作用域中遮蔽了外层变量，此时该外层变量会被暂时的遮蔽了。\n非预期变量遮蔽： 由于编写代码的过程中疏忽了导致了外层变量被遮蔽，从而导致程序产生了bug。简而言之就是开发者想要操作外层变量，但是是实际上操作的是内层作用域的变量。\n下面展示一个由于不变量的非预期遮蔽从而产生的副作用：\nfunc TestUnintendedVariableShadowing(t *testing.T) { var client *http.Client tracing := false if tracing { client, err := createClientWithTracing() //重现定义了client变量，该变量只存在if作用域，与外层作用域的client是两个独立的变量 if err != nil { fmt.Println(err) } log.Println(client) } else { client, err := createDefaultClient() if err != nil { fmt.Println(err) } log.Println(client) } useClient(client) } func createClientWithTracing() (*http.Client, error) { return \u0026amp;http.Client{}, nil } func createDefaultClient() (*http.Client, error) { return \u0026amp;http.Client{}, nil } func useClient(client *http.Client) { if client == nil{ fmt.Println(\u0026#34;nil client\u0026#34;) }else{ fmt.Println(\u0026#34;正确传入client\u0026#34;) } } 首先根据上述代码，我们可以发现，在if语句块中client使用了短变量声明运算符，此时的client是全新的变量，我们本来想着是生成tracing client 或者默认client 然后使用该client，但是最后我们发现，useClient传入的参数是nil。\n如何修改上述代码，让其外层变量不被遮蔽：\n在if语句块中创建临时变量，然后再语句块尾部将该临时变量赋值给外层的client。 func TestUnintendedVariableShadowing(t *testing.T) { var client *http.Client tracing := false if tracing { c, err := createClientWithTracing() //重现定义了client变量，该变量只存在if作用域，与外层作用域的client是两个独立的变量 if err != nil { fmt.Println(err) } log.Println(c) client = c } else { c, err := createDefaultClient() if err != nil { fmt.Println(err) } log.Println(c) client = c } useClient(client) } func createClientWithTracing() (*http.Client, error) { return \u0026amp;http.Client{}, nil } func createDefaultClient() (*http.Client, error) { return \u0026amp;http.Client{}, nil } func useClient(client *http.Client) { if client == nil { fmt.Println(\u0026#34;nil client\u0026#34;) } else { fmt.Println(client) } } 还有一种解决方案就是类似于上述情况，内部作用域变量是通过函数创建的，那么可以先声明一个error类型的变量，然后使用=操作符而不是:=短变量声明操作符。\nfunc TestUnintendedVariableShadowing(t *testing.T) { var client *http.Client tracing := false var err error if tracing { client, err = createClientWithTracing() //重现定义了client变量，该变量只存在if作用域，与外层作用域的client是两个独立的变量 if err != nil { fmt.Println(err) } log.Println(client) } else { client, err = createDefaultClient() if err != nil { fmt.Println(err) } log.Println(client) } useClient(client) } 如果使用了第二种方案，可以将没有必要在每一个条件分支进行处理error，因为条件分支判断err逻辑是一样的，这样可以在两个条件分支外层判断该err。\nfunc TestUnintendedVariableShadowing(t *testing.T) { var client *http.Client tracing := false var err error if tracing { client, err = createClientWithTracing() //重现定义了client变量，该变量只存在if作用域，与外层作用域的client是两个独立的变量 log.Println(client) } else { client, err = createDefaultClient() log.Println(client) } if err != nil { fmt.Println(err) } useClient(client) } 如何避免非预期变量遮蔽\n遵循清晰的命名规范，避免同名冲突， ​\t拒绝使用count,data,num等通用的变量名，给变量起【具有描述性】的名字，比如：globalIrderCount,localNewOrderCount,从根源减少不同作用域的同名概率。\n利用开发工具和静态检查工具，在开发阶段即使发现遮蔽问题。 避免不必要的变量声明。 ","date":"2026年01月17日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/100-go-mistakes/code-and-project/1-unintended-variable-shadowing/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003eUnintended Variable Shadowing\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003cp\u003e\u003ccode\u003eUintended Variable Shadowing\u003c/code\u003e中文翻译过来是：非预期变量遮蔽\u003c/p\u003e\n\u003cp\u003e在讲解什么是非预期变量遮蔽前需要知道什么是\u003cfont color=\"  #FF6347\"\u003e\u003cb\u003e变量遮蔽\u003c/b\u003e\u003c/font\u003e。\u003c/p\u003e\n\u003cp\u003e变量遮蔽： 当内层作用域中定义了一个与外层变量同名的变量，此时在内层作用域中遮蔽了外层变量，此时该外层变量会被暂时的遮蔽了。\u003c/p\u003e","tags":null,"title":"unintended-variable-shadowing"},{"categories":null,"contents":" Go语言内置类型 对于类型来说，需要清楚两个问题：\n需要分配多少内存？ 这些内存用于存储什么类型？ 1. 整数 对于整型类型来说：\nint 和 uint:\nint8：\n内存： 1个字节(8 bit) 存储类型： 有符号整数 范围： -128 - 127 int16\n内存： 2个字节(16- bit) 存储类型： 有符号整数 范围： -32768 - 32767 int32\n内存： 4个字节(32- bit) 存储类型： 有符号整数 范围： -2147483648 - 2147483647 int64\n内存： 8字节个字节(64 bit) 存储类型： 有符号整数 范围： -9223372036854775808 - 9223372036854775807 uint8\n内存： 1个字节(8 bit) 存储类型： 无符号整数 范围：0 - 255 uint16\n内存： 2个字节(16 bit) 存储类型： 无符号整数 范围： 0-65535 uint32\n内存： 4个字节(32 bit) 存储类型： 无符号整数 范围： 0-4294967295 uint64\n内存： 8个字节(64 bit) 存储类型： 无符号整数 范围：0-18446744073709551615 ​\t如果我们使用非精确类型\nint或者uint来声明变量时，该变量的存储大小实际上取决于用于构建程序的硬件架构。\n​\t32位架构： int用4字节存储有符号整数，uint用4字节存储无符号整数\n​\t64位架构： int用8字节存储有符号整数，uint用8字节存储无符号整数。\n2. float ​\tGo语言遵循IEEE 754二进制浮点算数标准，仅支持两种类型浮点数:\nfloat32 IEEE 754标准：单精度浮点数 字节数：4字节 指数位长度： 8bit 位数为长度: 23位 有效十进制精度(约): 6-7位 ​\nfloat64 IEEE 754标准：双精度浮点数 字节数：8字节 指数位长度： 11bit 尾位数为长度: 52位 有效十进制精度(约): 15-16位 未精确指定float的时候默认是float64。\n浮点数存在固有舍入误差，无法精确表示部分十进制小数，比较时需使用容差判断，避免直接使用 ==。\n3. bool // true and false are the two untyped boolean values. const ( true = 0 == 0 // Untyped bool. false = 0 != 0 // Untyped bool. ) bool类型只有两个值，true或者false， 在Go语言中不能将整型变量直接转换成bool类型，也不能将bool类型转换成整型。\n4. string // string is the set of all strings of 8-bit bytes, conventionally but not // necessarily representing UTF-8-encoded text. A string may be empty, but // not nil. Values of string type are immutable. type string string 字符串类型在go1.20版本中没有在builtin.go中具体实现，但是在builtin.go文件中类型定义了string,在builtin.go文件中递归类型定义了string，递归类型定义只能适用于内置基本类型，普通自定义类型无法复刻。\ntype int int //如果类型定义类型本身，则会有错误提示 //invalid recursive type: int refers to itself 在builtin.go文件中我们可以知道 字符串是所有8位字节的字符串的集合，通常但不一定表示UTF-8编码的文本。字符串可以是空的，但不是nil。字符串类型的值是不可变的。\n","date":"2026年01月16日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/ultimate-go-notebook/language-mechanics/builtin-types/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003eGo语言内置类型\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003cp\u003e对于类型来说，需要清楚两个问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e需要分配多少内存？\u003c/li\u003e\n\u003cli\u003e这些内存用于存储什么类型？\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"1-整数\"\u003e1. 整数\u003c/h2\u003e\n\u003cp\u003e对于整型类型来说：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eint\u003c/code\u003e 和 \u003ccode\u003euint\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eint8\u003c/code\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e内存： 1个字节(8 bit)\u003c/li\u003e\n\u003cli\u003e存储类型： 有符号整数\u003c/li\u003e\n\u003cli\u003e范围： -128  -  127\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eint16\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e内存： 2个字节(16- bit)\u003c/li\u003e\n\u003cli\u003e存储类型： 有符号整数\u003c/li\u003e\n\u003cli\u003e范围： -32768  -  32767\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eint32\u003c/code\u003e\u003c/p\u003e","tags":null,"title":"内置类型"},{"categories":null,"contents":" Unnecessary nested code Unnecessary nested code中文： 不必要的嵌套代码\n首先我们分析一个丑陋的例子：\n// 很丑陋的版本 func join(s1, s2 string, max int) (string, error) { if s1 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s1 is empty\u0026#34;) } else { if s2 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s2 is empty\u0026#34;) } else { concat, err := concatenate(s1, s2) if err != nil { return \u0026#34;\u0026#34;, err } else { if len(concat) \u0026gt; max { return concat[:max], nil } else { return concat, nil } } } } } func concatenate(s1, s2 string) (string, error) { return s1 + s2, nil } 这个例子虽然逻辑上是正确的，但是它涵盖了太多层次的if-else，导致代码阅读起来相对困难，你个良好的代码，是在大致阅读代码的时候就知道这段代码是什么意思，而不是需要一步一步的看。\n对于上述代码的优化版本：\n// 自行先优化一下 func joinV2(s1, s2 string, max int) (string, error) { if s1 == \u0026#34;\u0026#34; || s2 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s1 or s2 is empty\u0026#34;) } concat, err := concatenate(s1, s2) if err != nil { return \u0026#34;\u0026#34;, err } if len(concat) \u0026gt; max { return concat[:max], nil } return concat, nil } // 100 mistakes 书本中在不涉及改动部分功能下优化版本 func joinV3(s1, s2 string, max int) (string, error) { if s1 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s1 is empty\u0026#34;) } if s2 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s2 is empty\u0026#34;) } concat, err := concatenate(s1, s2) if err != nil { return \u0026#34;\u0026#34;, err } if len(concat) \u0026gt; max { return concat[:max], nil } return concat, nil } 一般来说函数所需的嵌套层次越多，就与但阅读和理解。\n接下来我们来看一下，如何避免太多层次的if-else。\n当一个if语句块返回时，我们应该在所有情况下省略else语句块。\n当然也可以走一个相反的路径，比如说if condition {return }那么我们也可以将condition修改为`if !condition{//执行业务逻辑}else {return}。\n尽可能将正常执行的代码，对齐到代码的左侧。\n我们分析一下糟糕版本的代码，发现正常执行的代码一直在右侧挪动，如果这个嵌套层次更深，那么正常执行的代码还要继续往右侧移动。所以说我们尽可能将正常执行的逻辑对齐到代码的左侧，这样在阅读代码的过程中，很轻易的知道这段代码到底是要做什么。\n","date":"2026年01月17日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/100-go-mistakes/code-and-project/2-unnecessary-nested-code/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003eUnnecessary nested code\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003cp\u003e\u003ccode\u003eUnnecessary nested code\u003c/code\u003e中文： 不必要的嵌套代码\u003c/p\u003e\n\u003cp\u003e首先我们分析一个丑陋的例子：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 很丑陋的版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ejoin\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003es1\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003es2\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003emax\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e) (\u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerrors\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eNew\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;s1 is empty\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerrors\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eNew\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;s2 is empty\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#a6e22e\"\u003econcat\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econcatenate\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003es1\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003es2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e len(\u003cspan style=\"color:#a6e22e\"\u003econcat\u003c/span\u003e) \u0026gt; \u003cspan style=\"color:#a6e22e\"\u003emax\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econcat\u003c/span\u003e[:\u003cspan style=\"color:#a6e22e\"\u003emax\u003c/span\u003e], \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t} \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econcat\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econcatenate\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003es1\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003es2\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e) (\u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es2\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个例子虽然逻辑上是正确的，但是它涵盖了太多层次的if-else，导致代码阅读起来相对困难，你个良好的代码，是在大致阅读代码的时候就知道这段代码是什么意思，而不是需要一步一步的看。\u003c/p\u003e","tags":null,"title":"Unnecessarty nested code"},{"categories":null,"contents":" 字长 ​\t字长是指，在某种特定架构下，存储整数及指针所需要分配的内存容量。\n​\t32位架构： 字长位4字节，因此需要分配4字节的内存空间。\n​\t64位架构： 字长位8字节，因此需要分配8字节的内存空间。\n​\t也就意味这指针类型变量，分配4字节或者8字节，根据不同的架构分配不同的大小的内存空间。\n​\t所以在相同的架构环境下，对于int、指针或者字的数据来说，为他们分配的内存容量始终相同的。\n","date":"0001年01月01日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/ultimate-go-notebook/language-mechanics/word-size/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003e字长\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003cp\u003e​\t字长是指，在某种特定架构下，存储整数及指针所需要分配的内存容量。\u003c/p\u003e\n\u003cp\u003e​\t32位架构： 字长位4字节，因此需要分配4字节的内存空间。\u003c/p\u003e\n\u003cp\u003e​\t64位架构： 字长位8字节，因此需要分配8字节的内存空间。\u003c/p\u003e","tags":null,"title":"字长"},{"categories":null,"contents":" misusing-init-functions 滥用初始化函数 Go语言中的init函数 ​\t在Go语言中，init函数是一个内置的特殊函数，其主要特征如下：\n函数签名固定： func init(){}无参数、无返回值 无法被程序显式调用 由Go语言运行时系统在程序启动阶段自动执行。 init 执行规则 init函数的执行是在包级全局变量初始化之后，main函数执行之前\n// utils.go package utils import \u0026#34;fmt\u0026#34; var Count int func init() { Count = 1 fmt.Println(\u0026#34;我是init函数，我是否在main函数执行之前\u0026#34;) } func AddCount() { Count++ } func GetCount() int { return Count } // main.go package main import ( \u0026#34;100-mistakes/code-and-project/utils\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(utils.GetCount()) utils.AddCount() fmt.Println(utils.GetCount()) } // output: // 我是init函数，我是否在main函数执行之前 // 1 // 2 从上面的程序运行结果可以看出，init是在main函数之前就执行了。\n多个init函数执行的顺序：\n同一个源文件下，init的执行顺序为定义顺序 // init.go package utils import \u0026#34;fmt\u0026#34; func init() { fmt.Println(1) } func init() { fmt.Println(2) } func init() { fmt.Println(3) } func init() { fmt.Println(4) } func init() { fmt.Println(5) } func init() { fmt.Println(6) } // 首先不用再main中单独引入该源文件，由于上面的程序中已经引入该包，而init函数的执行过程中是在包导入的时候就执行了 // output： // 1 // 2 // 3 // 4 // 5 // 6 同一个包内多个源文件： 按照源文件名称的字字母顺序执行。 ​\t就按照上述utils包中有两个源文件add.go和init.go，这两个源文件中都定义了一个或者多个init函数，按照字母顺序add.go中的init函数是优先执行，然后再是init.go中的init函数。\n不同包之间，按照导入依赖的顺序，被导入的包先执行init然后是当前包的init。 init函数的常见使用场景 初始化全局变量 ​\t首先我们知道init函数的执行是在包全局变量初始化之后，在main函数之前，那么我们可以在使用全局变量之前将复杂赋值的逻辑放在init函数中，这样在导入包的过程中，全局变量就已经初始化完成了。\n注册驱动/插件 ​\tGo生态中很多场景依赖init函数注册驱动，比如数据库驱动.\n加载配置/初始化资源\n比如程序启动时读取配置文件、初始化数据库连接池\n何时应该正确使用init函数 不合理的例子：\npackage utils import ( \u0026#34;database/sql\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var DB *sql.DB // 在init中链接数据库 func init() { dsn := \u0026#34;foreverool:010101@tcp(127.0.0.1:3306)/study_mysql?charset=utf8mb4\u0026amp;parseTime=True\u0026amp;loc=Local\u0026#34; db, err := sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { panic(err) } err = db.Ping() if err != nil { panic(err) } DB = db } 为什么上述例子不合理呢？\n由于init函数的返回错误，所以在内部我们只能通过panic来展示错误，这样做程序就中止了，如果我们想采取重试机制链接数据库，这样通过init函数没有办法做到。\n如果我们在对于该文件进行测试，在测试之前，init函数就已经执行，这可能不是我们想要的，因为我们有可能测试的对象就是连接数据库逻辑是否正确。\n最后一个缺点就是将数据库连接池赋值给一个全局变量，而全局变量存在一些严重的缺陷。\n包内任何函数都可以修改全局变量 单元测试可能变得更加复杂，因为依赖于全局变量的函数将不再能独立地测试了。 在大多数情况下下，我们应该优先将变量封装起来，而不是将其设置为全局变量。基于这些原因我们应该之前的初始化操作应该被作为一个普通函数来处理：\nfunc CreateDB(dsn string) (*sql.DB, error) { db, err := sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { return nil, err } err = db.Ping() if err != nil { return nil, err } return db, nil } 这样的函数，错误的处理将由调用者来处理，而不是直接panic，并且该函数可以独立的使用测试函数进行测试。\nAd Hoc函数\n​\tAd Hoc函数是指为解决特定的、临时的问题而编写的函数，并不是为了复用性创建的函数。通常只在特定场景下使用。\n阅读完本篇文章：\n​\t个人觉得：\n​\t如果init函数内部可能出现错误处理，那么就不要使用init函数实现该部分内容而是单独定义一个可以被调用者显式调用的函数。\n​\t如果init函数实现的功能需要单元测试该部分内容是否正确，那么就不要使用init函数，而是单独定义。\n​\n","date":"2026年01月22日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/100-go-mistakes/code-and-project/3-misusing-init-functions/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003emisusing-init-functions\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003ch1 id=\"滥用初始化函数\"\u003e滥用初始化函数\u003c/h1\u003e\n\u003ch2 id=\"go语言中的init函数\"\u003eGo语言中的init函数\u003c/h2\u003e\n\u003cp\u003e​\t在\u003ccode\u003eGo\u003c/code\u003e语言中，\u003ccode\u003einit\u003c/code\u003e函数是一个内置的特殊函数，其主要特征如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e函数签名固定： \u003ccode\u003efunc init(){}\u003c/code\u003e无参数、无返回值\u003c/li\u003e\n\u003cli\u003e无法被程序\u003cstrong\u003e显式\u003c/strong\u003e调用\u003c/li\u003e\n\u003cli\u003e由\u003ccode\u003eGo\u003c/code\u003e语言运行时系统在程序启动阶段自动执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"init-执行规则\"\u003einit 执行规则\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003einit\u003c/code\u003e函数的执行是在\u003cstrong\u003e包级全局变量初始化之后，main函数执行之前\u003c/strong\u003e\u003c/p\u003e","tags":null,"title":"misusing-init-functions"},{"categories":null,"contents":" 零值的概念 ​\t我们创建的每个变量在其初始化时，其值至少被设置位零，也就是当我们声明变量时，go在编译过程中，会自动位该变量进行初始化，也就是为相应的变量的存储空间内存储相应的零值。如果我们在声明变量的时候就指定初始值，那么该变量在使用的时候，其值就是我们预先指定的值。 所谓“零值”就是指每个字节的每一位都被设置为零。\n​\t零值确保了数据的完整性，也就是说在我们使用一个声明的变量过程中，该变量符合我们的预期而不是在使用的时候出现一些未知的值存在我们的变量中。\n​\tgo语言的内置类型的零值如下：\nboolean: false Integer: 0 Float : 0.0 Complex: 0i String: \u0026ldquo;\u0026quot;(empty) Pointer: nil rune: 0 byte: 0 复合类型由一个或多个基本类型组成，其零值遵循【成员各自取对应的类型零值】规则。\n数组： 数组的每个元素都取该元素类型的零值，与数组长度无关。\n结构体： 结构体的零值是【结构体每个字段都取该字段类型的零值】，嵌套结构体也遵循此规则，逐层递归赋零值。\n引用类型：\n引用类型的零值都是nil\n切片 []int, nil切片的len()、cap()均为0，可直接使用append()无需手动初始化。 // 查看空结构体的值 var nilSlice []int if nilSlice == nil { fmt.Println(\u0026#34;nil slice\u0026#34;) } else { fmt.Printf(\u0026#34;%+v\\n\u0026#34;, nilSlice) } // output : nil slice //查看nil slice len() cap() fmt.Printf(\u0026#34;len=%d, cap=%d\\n\u0026#34;, len(nilSlice), cap(nilSlice)) // output:len=0, cap=0 // 对nil slice进行append nilSlice = append(nilSlice, 1) fmt.Printf(\u0026#34;len=%d, cap=%d\\n\u0026#34;, len(nilSlice), cap(nilSlice)) fmt.Println(nilSlice) // output: // len=1, cap=1 //\t[1] var nilSlice1 []int // 使用函数添加元素，但是传入的参数是nil AppendElement(nilSlice1, 1) if nilSlice1 == nil { fmt.Println(\u0026#34;nil slice\u0026#34;) } else { fmt.Printf(\u0026#34;len=%d, cap=%d\\n\u0026#34;, len(nilSlice), cap(nilSlice)) fmt.Println(nilSlice1) } // output: nil slice // 由于形参是值传递，而通过函数传递给的nilSlice1最终添加了元素并没有返回给main。 字典map[k]v , nilmap无法直接添加键值对，必须通过make进行初始化，或者字面量初始化map[int]int{}。\nvar nilmap map[int]int fmt.Println(len(nilmap)) // output : 0 //直接添加键值对 nilmap[1] = 12 if nilmap == nil { fmt.Println(\u0026#34;nil map\u0026#34;) } else { fmt.Println(\u0026#34;len=\u0026#34;, len(nilmap)) fmt.Println(nilmap) } // output: // panic: assignment to entry in nil map [recovered] // panic: assignment to entry in nil map //所以为了程序的健壮性，所以在使用map的时候尽量先对map进行nil判断，然后在进行业务处理 通道 chan T nil通道无法进行发送/接受，必须通过make进行使用。\n函数 nil的直接调用会引发panic。\n指针 nil指针无法解引用，如果解引用会引发panic。\n接口 nil接口的零值要求动态类型和动态值都为nil，nil接口无法调用任何方法。\n","date":"2026年01月16日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/ultimate-go-notebook/language-mechanics/zero-value-concept/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003e零值的概念\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003cp\u003e​\t我们创建的每个变量在其初始化时，其值至少被设置位零，也就是当我们声明变量时，go在编译过程中，会自动位该变量进行初始化，也就是为相应的变量的存储空间内存储相应的零值。如果我们在声明变量的时候就指定初始值，那么该变量在使用的时候，其值就是我们预先指定的值。 所谓“零值”就是指每个字节的每一位都被设置为零。\u003c/p\u003e","tags":null,"title":"零值的概念"},{"categories":null,"contents":" overusing-getters-and-setters Overusing getters and setters 说起getters 和setters我个人感觉在java中十分常见，由于java是纯面向对象语言，所以经常会将某些字段定义为private然后使用getter 和setter进行操作该priavte字段。但是在Go语言中我在很多源码中并没有看到getter和setter，而是直接操作struct中的字段。除非该字段被设置为当前包可见。\n首先说明：\n​\tGo不强制使用getter和setter，在标准库中也不强制使用。但是getter和setter具有一些优点：\n封装了字段的设置与获取行为，允许在获取或者设置过程中添加新的行为（验证字段，返回计算值等） 隐藏了内部表示 在Go语言如何使用getter和setter呢？\n​\t如果我们要为balance字段设置getter和setter,那么我们的getter方法应该是Balance()而不是GetBalance()。\n​\t而setter应该命名为SetBalance。\n如果我们的getter和setter就只是简单的取值，赋值，那么没有必要为该字段设置getter和setter。\n只有当我们的getter和setter方法有有意义时才使用，遵循go语言的设计哲学\n简单。 ","date":"2026年01月22日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/100-go-mistakes/code-and-project/4-overusing-getters-and-setters/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003eoverusing-getters-and-setters\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003ch1 id=\"overusing-getters-and-setters\"\u003eOverusing getters and setters\u003c/h1\u003e\n\u003cp\u003e说起getters 和setters我个人感觉在\u003ccode\u003ejava\u003c/code\u003e中十分常见，由于\u003ccode\u003ejava\u003c/code\u003e是纯面向对象语言，所以经常会将某些字段定义为\u003ccode\u003eprivate\u003c/code\u003e然后使用getter 和setter进行操作该\u003ccode\u003epriavte\u003c/code\u003e字段。但是在\u003ccode\u003eGo\u003c/code\u003e语言中我在很多源码中并没有看到\u003ccode\u003egetter\u003c/code\u003e和\u003ccode\u003esetter\u003c/code\u003e，而是直接操作\u003ccode\u003estruct\u003c/code\u003e中的字段。除非该字段被设置为当前包可见。\u003c/p\u003e","tags":null,"title":""},{"categories":null,"contents":" 声明与初始化 1 var 关键字var可以用于所有类型的变量设置为初始状态，零值。\ntype User struct{ Name string Age uint8 } var i8 int8 var u8 uint8 var condition bool var user User 在go语言中字符串底层结构由两个字组成：\ntype stringStruct struct { str unsafe.Pointer len int } 如果string被设置为nil， 那么字段str则是nil，len为0。\n2 短变量声明操作符 短变量声明操作符:=\n该操作符包含了声明变量，初始化变量，赋值变量三个步骤。\n如果一个变量已经声明了或者定义了，就无法再次使用短变量声明操作符。\n","date":"2026年01月16日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/ultimate-go-notebook/language-mechanics/declare-initialize/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003e声明与初始化\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003ch2 id=\"1-var\"\u003e1 var\u003c/h2\u003e\n\u003cp\u003e关键字\u003ccode\u003evar\u003c/code\u003e可以用于所有类型的变量设置为初始状态，零值。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eUser\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003euint8\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ei8\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint8\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eu8\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003euint8\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econdition\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eUser\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在\u003ccode\u003ego\u003c/code\u003e语言中字符串底层结构由两个字组成：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003estringStruct\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003estr\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eunsafe\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePointer\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003elen\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果string被设置为nil， 那么字段\u003ccode\u003estr\u003c/code\u003e则是\u003ccode\u003enil\u003c/code\u003e，len为0。\u003c/p\u003e","tags":null,"title":"声明和初始化"},{"categories":null,"contents":" 转换与类型转换 go语言不支持隐式类型转换，并且显示类型转换不是将原有类型的转换为需要的类型，而是创建一个目标的新变量变量，对其进行赋值，然后将该变量赋值到我们指定的变量中（不是被转换的变量）。\n显示转换形式：\n// 格式 目标类型(源变量/值) // string([]byte) // []byte(\u0026#34;string value\u0026#34;) source := \u0026#34;string value\u0026#34; fmt.Println(\u0026#34;source address: \u0026#34;, \u0026amp;source) target := []byte(source) fmt.Println(\u0026#34;source address: \u0026#34;, \u0026amp;source) fmt.Println(\u0026#34;target address: \u0026#34;, \u0026amp;target) //output : //\tsource address: 0xc000026300 //\tsource address: 0xc000026300 // target address: \u0026amp;[115 116 114 105 110 103 32 118 97 108 117 101] ","date":"2026年01月16日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/ultimate-go-notebook/language-mechanics/conversion-casting/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003e转换与类型转换\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003cp\u003e\u003ccode\u003ego\u003c/code\u003e语言不支持隐式类型转换，并且显示类型转换不是将原有类型的转换为需要的类型，而是创建一个目标的新变量变量，对其进行赋值，然后将该变量赋值到我们指定的变量中（不是被转换的变量）。\u003c/p\u003e\n\u003cp\u003e显示转换形式：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 格式 目标类型(源变量/值)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// string([]byte)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// []byte(\u0026#34;string value\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003esource\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;string value\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;source address: \u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003esource\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e []byte(\u003cspan style=\"color:#a6e22e\"\u003esource\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;source address: \u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003esource\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;target address: \u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003etarget\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e//output :\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e//\tsource address:  0xc000026300\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e//\tsource address:  0xc000026300\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e// target address:  \u0026amp;[115 116 114 105 110 103 32 118 97 108 117 101]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n            \u003c/div\u003e\n        \n    \u003c/div\u003e\n\u003c/div\u003e","tags":null,"title":"类型转换"},{"categories":null,"contents":" Interface ​\t接口在Go中提供纯粹的抽象。接口的主体只能有方法声明和嵌入式的接口。接口中的方法没有主体，只能在接口中定义方法签名。\n1.定义接口的语法 定义接口的语法如下：\ntype InterfaceName interface{ methodName(argument arguments-type...)returnType } 可以看到定义接口的语法与定义一个结构体类型相似，都是使用type关键字。\n例子：\ntype Executor interface { Execute() } 如果一个接口只有一个方法，那么接口名称则是这个方法的名称+[e]r。在上述例子中，我们的接口只有一个方法Execute所以我们的接口名称为Executor。这种命名规则不是Go硬性条件，而是一种惯例，这种管理方便了解该接口的具体的功能。\n在Go语言中，接口可以有一个或多个方法。\ntype Connection interface { Open(uri string) (session, error) Close() error } 如果一个接口有多个方法，如何命名呢？\n根据接口的职责进行命名，一般是名词而非动词。如果一个接口由两个或多个小接口组合而成，那么接口名可以拼接小接口名。\n// Implementations must not retain p. type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } // ReadWriter is the interface that groups the basic Read and Write methods. type ReadWriter interface { Reader Writer } 2. 实现接口 在Go语言中接口不像Java中那样需要显示使用implements关键字实现接口，而是采用一种隐式的方式，只要一个类型具有在接口中定义的所有方法，则该类型是实现该接口的。\ntype Executor interface { Execute() } type Thread struct { } func (t Thread) Execute() { fmt.Println(\u0026#34;Executing thread\u0026#34;) } func TestInterface(t *testing.T) { var exe Executor exe = Thread{} exe.Execute() } // output : Executing thread 如果一个类型没有实现接口的中的所有方法，那么在将该对象赋值给接口变量的时候，编译会发生错误。\n由于接口中的方法没有函数体，所以当我们在没有给接口变量赋值相应的对象时，直接使用接口那么该接口变量将是无用的，此时该变量将被设置为nil，如果调用一个没有赋值过的接口变量，则会触发panic。\n要实现一个接口，必须实现该接口的所有方法，如果仅仅实现了接口的一部分方法，那还是意味着没有实现该接口，也就无法将该对象赋值给接口变量了\ntype Connection interface { Open(uri string) (session, error) Close() error } type HttpConnnection struct{} func (h HttpConnnection) Close() error { return nil } func TestInterface(t *testing.T) { var connection Connection connection = HttpConnnection{} } 3. 为什么要隐式实现 Go语言的设计哲学是简洁、实用、松耦合，隐式实现接口正是这一哲学的集中体现。\n极致的简洁性：消除了冗余代码，符合“少即是多” 在Go语言中不需要使用类似implements关键字显示实现接口，那么这样就减少了不必要的代码，如果一个类型所以要实现的接口变了，那么就需要手动的修改类型代码，这样做显得冗余。 松耦合：实现者与接口解耦，支持“接口后置” 隐式实现的核心优势：实现者无需感知接口的存在，一个类型可以先定义并实现方法，后续再定义接口来“适配”这个类型，而非必须先定义接口然后再让类型去迎合接口。 灵活性：适配已有类型，符合“开闭原则” 隐式实现允许你为已有类型（甚至第三方库类型）适配新接口，而无需修改原有类型的源码。 4. 多态性 如果一个函数的参数是接口类型，然后函数体中使用了该接口中的多个方法，我们无需知道传递的到底是什么对象，只需要知道该方法可以被调用即可，因为他们实现了同一个接口，返回类型、函数参数都是相同的，所以可以在函数参数中传递不同的对象类型（只要实现了相同的接口即可）\ntype Bird interface { Fly() } type Eagle struct{} func (e Eagle) Fly() { fmt.Printf(\u0026#34;I\u0026#39;m Eagle.\\n I\u0026#39;m flying over the cloud!\\n\u0026#34;) } type Pigeon struct { } func (p Pigeon) Fly() { fmt.Printf(\u0026#34;I\u0026#39;m Pigeon.\\n I\u0026#39;m flying on normal height\\n\u0026#34;) } type Penguin struct{} func (p Penguin) Fly() { fmt.Printf(\u0026#34;I\u0026#39;m Penguin.\\n I can not fly\\n\u0026#34;) } func flyNow(bird Bird) { bird.Fly() } func TestInterface(t *testing.T) { flyNow(Eagle{}) flyNow(Pigeon{}) flyNow(Penguin{}) } 我们以游戏视角来看，所有英雄都有3个技能，只是每个技能效果是不同的，但是用户通过键盘输入是一样的，我们可以为每个英雄定义一个类型，然后再与键盘交互的时候传入相应的类型给接口类型即可。\npackage utils import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) type Hero interface { Skill1() string Skill2() string Skill3() string HandInput(input string) string } // 战士 type Warrior struct { Name string } func (w Warrior) Skill1() string { return fmt.Sprintf(\u0026#34;[%s] 释放技能1：冲锋！造成30物理伤害！\u0026#34;, w.Name) } func (w Warrior) Skill2() string { return fmt.Sprintf(\u0026#34;[%s] 释放技能2：锁链！造成10物理伤害，并控制敌方0.5s！\u0026#34;, w.Name) } func (w Warrior) Skill3() string { return fmt.Sprintf(\u0026#34;[%s] 释放技能3：斩杀！造成100物理伤害，100魔法伤害！\u0026#34;, w.Name) } func (w Warrior) HandInput(input string) string { input = strings.TrimSpace(input) input = strings.ToLower(input) switch input { case \u0026#34;q\u0026#34;: return w.Skill1() case \u0026#34;w\u0026#34;: return w.Skill2() case \u0026#34;e\u0026#34;: return w.Skill3() default: return fmt.Sprintf(\u0026#34;[%s] 无效输入！请输入q/w/e释放相应技能\u0026#34;, w.Name) } } // 法师 type Mage struct { Name string } func (m Mage) Skill1() string { return fmt.Sprintf(\u0026#34;[%s] 释放技能1：火球术！造成20魔法伤害！\u0026#34;, m.Name) } func (m Mage) Skill2() string { return fmt.Sprintf(\u0026#34;[%s] 释放技能2：冰锥术！造成12魔法伤害，并控制敌方0.5s！\u0026#34;, m.Name) } func (m Mage) Skill3() string { return fmt.Sprintf(\u0026#34;[%s] 释放技能3：斩杀！造成100物理伤害，100魔法伤害！\u0026#34;, m.Name) } func (m Mage) HandInput(input string) string { input = strings.TrimSpace(input) input = strings.ToLower(input) switch input { case \u0026#34;q\u0026#34;: return m.Skill1() case \u0026#34;w\u0026#34;: return m.Skill2() case \u0026#34;e\u0026#34;: return m.Skill3() default: return fmt.Sprintf(\u0026#34;[%s] 无效输入！请输入q/w/e释放相应技能\u0026#34;, m.Name) } } func GameInteraction(hero Hero) { scanner := bufio.NewScanner(os.Stdin) fmt.Printf(\u0026#34;\\n欢迎使用英雄【%T】！输入1/2/3释放技能，输入q退出\\n\u0026#34;, hero) for { fmt.Print(\u0026#34;请输入指令：\u0026#34;) scanner.Scan() input := scanner.Text() if input == \u0026#34;quit\u0026#34; { fmt.Println(\u0026#34;退出游戏交互！\u0026#34;) break } result := hero.HandInput(input) fmt.Println(result) } } 分析上述代码我们知道，游戏交互界面主要考虑的是用户输入了什么，不考虑英雄技能是如何施展的，而且每一个英雄都有相同的行为，释放技能，处理输入。所以在游戏交互的时候，我们直接使用接口，哪怕后续技能效果改变了也不影响我们的交互逻辑。\n5. empty interface 在Go语言中，没有任何方法的接口称之为空接口。\n由于所有类型都满足空接口，所以我们可以将任意类型的值赋给空接口变量。\nfunc TestInterface(t *testing.T) { var empty interface{} // 也可以定义为any // 整数 empty = uint(1) fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) empty = int(1) fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) // 浮点数 empty = float32(1.12) fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) empty = float64(1.12) fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) // boolean empty = true fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) // 自定义类型 empty = User{Name: \u0026#34;foreverool\u0026#34;} fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) // slice empty = []int{1, 2, 3, 4} fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) // map m := make(map[string]int) m[\u0026#34;c\u0026#34;] = 1 m[\u0026#34;a\u0026#34;] = 2 empty = m fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) // pointer mp := \u0026amp;m empty = mp fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) // function empty = func() {} fmt.Printf(\u0026#34;empty type is %T\\n\u0026#34;, empty) } // output: // empty type is uint // empty type is int // empty type is float32 // empty type is float64 // empty type is bool // empty type is codeandproject.User // empty type is []int // empty type is map[string]int // empty type is *map[string]int // empty type is func() 在Go 1.18中引入了any这个空接口的内置别名。也就是说为了书写简单，可以直接使用any，其和interface{}语义、功能都是完全等价的。\n然后我们在来看看标准库中是如何使用any的\nfunc Println(a ...any) (n int, err error) { return Fprintln(os.Stdout, a...) } func Printf(format string, a ...any) (n int, err error) { return Fprintf(os.Stdout, format, a...) } 我们以Println函数为例，无论我们传递什么类型参数，Println都能打印，就是因为其参数类型是any,在Go语言中所有类型都实现了空接口！！！\n6. 方法集 方法集是使类型隐式实现接口的一组方法。\n思考： 接口的实现者的方法的接收者是值还是指针？\n答案：接口方法不指定实现类型应该具有指针接收器还是值接收器。\n对于方法的接收者来说，一般情况下，如果需要对该类型内部的字段进行修改，那么会定义该方法的接收者是指针类型。如果有一个方法的接收者是指针类型，那么我们统一将该类型的所有方法的接收者都为指针类型。\n当然在调用方法的时候，Go编译器会自动转换T为*T。\ntype Form struct { account string password string } func (f *Form) Account() string { return f.account } func (f *Form) SetAccount(account string) error { if len(account) \u0026gt; 30 { return errors.New(\u0026#34;超出最大长度\u0026#34;) } f.account = account return nil } func (f *Form) SetPassword(password string) error { if len(password) \u0026gt; 30 { return errors.New(\u0026#34;超出最大长度\u0026#34;) } f.password = password return nil } func ReceiverTest() { // 值而非指针 form := Form{} form.SetAccount(\u0026#34;foreverool\u0026#34;) form.SetPassword(\u0026#34;010101\u0026#34;) fmt.Println(form.Account()) } 如果方法接收者是值类型【T】，在调用方法的时候会拷贝整个实例，方法内对字段的修改只作用于拷贝，原实例的字段不会被改变。 如果方法接收者是指针类型【*T】， 在调用方法的时候传递的是实例的内存地址，方法内对字段的修改会直接作用于原实例。 但是接口不像普通的方法调用那样，编译器会自动转换，如果一个类型实现了一个接口，并且这个类型的所有方法的接收者是指针类型，那么如果你传递给该接口变量一个值类型，那么会引发编译错误。\n这里需要将Form{}的地址赋值给former接口变量。\n造成该结果的原因是*Form实现了该接口而不是Form实现了。\n那么相反的情况会如何呢？ Form实现接口，传入该变量的地址会如何？\n并没有引起任何错误，那就意味着当我们的方法集使用值接收器，那么就意味着T和*T都实现了该接口。\n7. 接口与结构体 ​\t在Go语言中没有继承的概念，而是通过组合实现与继承一样的效果。我们可以通过将接口嵌入到结构体中（依赖注入），在使用该接口时，需要将实现了该接口的对象实例赋值到结构体字段中，这样该结构体可以直接调用该接口（Go语言的语法糖）。\n​\t需要注意的是，虽然结构体可以直接调用接口的方法，但不意味着该结构体实现了该接口，只是隐式的调用该结构体的某个字段的方法而已\n接口嵌入的本质是匿名字段 type Mover interface { Move() } type Jumper interface { Jump() } type Person struct { Name string Mover Jumper } type NormalPerson struct{} func (n NormalPerson) Move() { fmt.Println(\u0026#34;我正以每小时5公里的速度前进\u0026#34;) } func (n NormalPerson) Jump() { fmt.Println(\u0026#34;我每次跳跃30cm\u0026#34;) } type AthlecticPerson struct{} func (a AthlecticPerson) Move() { fmt.Println(\u0026#34;我正以每小时10公里的速度前进\u0026#34;) } func (a AthlecticPerson) Jump() { fmt.Println(\u0026#34;我每次跳跃60cm\u0026#34;) } func TestEmbededInterface(t *testing.T) { normal := NormalPerson{} athletic := AthlecticPerson{} person := Person{ Name: \u0026#34;Normal Person\u0026#34;, Mover: normal, Jumper: athletic, } person.Move() person.Jump() } 上述代码中Person结构体嵌套了Mover和Jumper接口，在使用person之前先将实现Mover和Jumper接口的类型的实例赋值到了person相应的匿名字段中，而在最后调用的时候直接调用只是Go的语法糖，其实际代码为：\nperson.Mover.Move() person.Jumper.Jump() 如果直接使用一个未被赋值一个实现相应接口的类型实例，直接使用该变量，则会直接引发panic。 如果结构体中也定义了与字段接口同名的方法，会覆盖掉字段中的方法。 func (p Person) Move() { fmt.Println(\u0026#34;我覆盖了！\u0026#34;) } // 执行上面的代码 // output: // 我覆盖了！ // 我每次跳跃60cm ","date":"2026年01月23日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/hand-on-go-programming/interfaces/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003ch1 id=\"interface\"\u003eInterface\u003c/h1\u003e\n\u003cp\u003e​\t接口在\u003ccode\u003eGo\u003c/code\u003e中提供纯粹的\u003cstrong\u003e抽象\u003c/strong\u003e。接口的主体只能有\u003cstrong\u003e方法声明和嵌入式的接口\u003c/strong\u003e。接口中的方法没有主体，只能在接口中定义方法签名。\u003c/p\u003e\n\u003ch2 id=\"1定义接口的语法\"\u003e1.定义接口的语法\u003c/h2\u003e\n\u003cp\u003e定义接口的语法如下：\u003c/p\u003e","tags":null,"title":"interface"},{"categories":null,"contents":"安装docker 在Windows上安装docker ​\t在之前的文章中我们了解到，windows内核并不像Linux在内核中支持容器相关功能，所以在Windows上安装docker需要安装Docker Desktop软件，该软件会先运行一个Linux虚拟机，然后再其上面安装docker。\n为什么再\u0026quot;Docker Deep Dive Zero to Do \u0026ldquo;书中极力建议安装Docker Desktop而不是在学习过程中就将docker安装在Linux中的主要原因就是：\n我们的主机OS可能时windows或者macOS，为了安装docker我们可能需要使用虚拟机安装Linux或者使用wsl。\nDocker Desktop 软件有一个良好的可视化操作流程，并不是简单的命令行工具。\n获取Docker Desktop 官方网址: https://www.docker.com/products/docker-desktop/\n需要注意的是在安装了docker desktop之前需要启用wsl。\n点击Download Docker Desktop 选择适合你主机OS的版本并下载。\n下载完成之后进行安装\n如果安装成功之后，就可以在CMD和WSL中使用docker了，这里需要注意的是命令行中的docker命令只是使用了docker的客户端，而真正的引擎是在WSL中。\n由于WSL与Windows并非完全隔离，其有专属的通信方式，所以Windows与WSL共用了docker守护进程。\n真正的docker守护进程是安装在docker desktop WSL中并不是你之前就已经安装了的wsl某个操作系统。\n你可以使用wsl --list命令查看你主机当前的所有wsl。\n","date":"2026年01月29日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/posts/docker/install-docker/","summary":"\u003ch1 id=\"安装docker\"\u003e安装docker\u003c/h1\u003e\n\u003ch2 id=\"在windows上安装docker\"\u003e在Windows上安装docker\u003c/h2\u003e\n\u003cp\u003e​\t在之前的文章中我们了解到，windows内核并不像Linux在内核中支持容器相关功能，所以在Windows上安装\u003ccode\u003edocker\u003c/code\u003e需要安装\u003ccode\u003eDocker Desktop\u003c/code\u003e软件，该软件会先运行一个\u003ccode\u003eLinux\u003c/code\u003e虚拟机，然后再其上面安装docker。\u003c/p\u003e","tags":null,"title":"Install Docker"},{"categories":null,"contents":"什么是Docker 在学习Docker之前先要了解一下虚拟机和容器。\n虚拟机和容器是两种核心的虚拟化技术，核心目标都是实现资源隔离与环境标准化，但二者的虚拟化层级、实现原理、资源占用、隔离性天差地别。\n虚拟机是硬件级虚拟化模拟完整的计算机硬件并运行独立的操作系统。 容器时操作系统级虚拟化，基于宿主主机内核实现进程级隔离，无独立的操作系统。 1. 虚拟机 1.1 核心定义 ​\t虚拟机是通过虚拟化软件(Hypervisor)在物理宿主主机上模拟出多套独立的硬件环境（CPU、内存、磁盘、网卡、主板等），每套硬件环境都能安装独立的操作系统和应用。在不同虚拟机之间完全隔离，彼此感知不到对方的存在，就像一台物理主机运行了多台\u0026quot;独立的电脑\u0026quot;。\n核心架构：\n​\t虚拟机的虚拟化是硬件层的抽象，架构从下到上分为：\n物理硬件 Hypervisor(虚拟化层) 多个虚拟机 虚拟机本身不能独立运行，必须依赖Hypervisor\u0026ndash;它是虚拟机的管理者，负责硬件资源的抽象、分配、中转，虚拟机的所有操作（启动、运行、资源调用）都由Hypervisor接管。\nHypervisor是虚拟机技术的关键，其一般有两种类型：\n跑在硬件之上的Hypervisor，虚拟机就基于硬件 + Hypervisor运行，无系统依赖。 跑在操作系统之上的Hypervisor，虚拟机就基于硬件+操作系统+Hypervisor运行，依赖于宿主主机OS。 第一种类型的Hypervisor一般用于企业端，直接跑在硬件上不需要依赖操作系统，在硬件之上虚拟多个操作系统。\n第二种类型的Hypervisor一般是面向于个人，比如vmware workstation软件，我们可以在操作系统上安装多个不同的操作系统。\n在windows上的wsl也是使用的第二种类型的Hypervisor。\n1.2 优缺点 优点 缺点 🔒 隔离性极强：硬件级隔离，虚拟机间无任何资源共享，一个虚拟机故障 / 崩溃不会影响其他虚拟机和宿主机 ⚡ 资源占用极高：每个虚拟机都包含完整 OS 和内核，预装大量系统库，镜像体积大，资源预先分配，利用率低 📌 OS 无关性：支持任意异构操作系统（Windows/Linux/macOS），可在 Linux 物理机上运行 Windows 虚拟机，反之亦然 🐢 启动速度慢：需要完整加载操作系统内核和系统服务，启动时间通常为分钟级（如 Windows 虚拟机启动约 1-3 分钟，Linux 约 30 秒 - 1 分钟） 🛡️ 安全性高：应用运行在独立的 Guest OS 中，即使应用被攻击，也仅局限在虚拟机内部，无法直接渗透到宿主机和其他虚拟机 📈 运维复杂：每个虚拟机都需要独立维护（更新系统、打补丁、安装依赖），多虚拟机场景下运维成本指数级上升 🎯 兼容性好：支持运行所有传统应用（如老旧的单机软件、未做容器化改造的企业级应用），无需修改应用代码 🚀 性能损耗：Hypervisor 的资源中转存在一定损耗，Type2 型损耗更明显 2. 容器 ​\t容器是操作系统级轻量隔离进程\n​\t容器的虚拟化是操作系统层的抽象，并非模拟硬件，而是基于宿主主机的内核，通过Linux内核的原生特性实现进程级的资源隔离和限制，容器本质是被隔离的、轻量的特殊进程\n核心定义\n​\t容器是在单一宿主机OS内核上，通过容器运行时实现进程隔离环境，每个容器仅包含应用程序+运行所需的依赖库/配置（无独立操作系统、无独立内核），共享宿主主机的内核和系统核心库。同时通过内核特性实现资源限制（CPU/内存）和环境隔离（网络/文件系统/进程），不同容器的进程彼此隔离，就像在一个OS上运行了多个独立的应用沙箱。\n核心架构：\n​\t容器的虚拟化技术是操作系统内核层的抽象，架构从下到上分为：\n物理硬件 宿主机操作系统 容器运行时 多个容器 windwos/macOS本身没有Linux的容器内核特性，所以相关docker软件（Docker Desktop\\Colima）会在本地启动一个轻量级Linux虚拟机，容器实际上运行在这个Linux虚拟机中。\nLinux宿主机上的容器无需额外虚拟机，直接基于内核运行，性能损耗很低。\n核心工作原理：\n​\t基于Linux内核三大核心特性\n容器的隔离和资源限制完全依赖于Linux内核的原生能力，无需额外虚拟化软件，这是它轻量、高速的底层原因。\nNamespaces命名空间：实现环境隔离\n对容器的进程、网络、文件系统、主机名、用户等进行隔离，让每个容器都有【独立的视角】:\n容器内的PID1进程，在宿主机上是一个普通的PID如1234，容器内无法查看宿主机和其它容器的进程。 容器内有独立的网卡和IP，与宿主机/其它容器的网络隔离，通过网桥实现通信。 cgroups(控制组):实现资源限制 对容器CPU、内存、磁盘IO、网络带宽等资源进行精准限制，比如限制某个容器最多使用1核CPU、2G内存，即使宿主机资源充足，容器也不会超额使用，避免单个容器占用全部资源导致其它容器崩溃。\nUnionFS(联合文件系统)：实现镜像分层与轻量化 这是Docker镜像核心技术，将容器镜像差分多个只读的分层，多个容器可以共享相同的分层（如多个python应用共享Python基础镜像层），仅在容器运行时创建唯一的可写层，大幅减少镜像体积和磁盘占用。\n核心组件：\n容器镜像： 容器的只读模板，包含应用运行所需的代码、依赖库、配置、系统工具，无完整OS和内核，体积为MB级，可通过Dockerfile构建，支持跨平台分发。 容器运行时： 负责容器的创建、启动、停止、销毁，是容器与内核的交互层。 容器引擎： 为用户提供可视化/命令行操作界面，封装运行时复杂操作。代表：Docker。 编排工具：解决多容器的集群管理问题，如容器启动顺序，负载均衡、故障恢复、扩缩容，云原生核心，代表k8s。 镜像仓库：用于存储和分发容器镜像，docker hub 优缺点\n优点 缺点 🚀 极致轻量：无独立 OS 和内核，仅包含应用和依赖，镜像体积为 MB 级，远小于虚拟机的 GB 级 🔗 内核依赖：同一宿主机的所有容器共享宿主机内核，无法运行与宿主机内核不兼容的 OS 应用（如 Linux 宿主机无法运行 Windows 原生应用，需通过 WSL / 虚拟机中转） ⚡ 启动速度极快：无需加载操作系统，仅启动一个特殊进程，启动时间为毫秒级 / 秒级（如 Docker 容器启动通常 \u0026lt; 1 秒） 🛡️ 隔离性弱于 VM：进程级隔离，基于内核特性实现，若内核存在漏洞，可能导致「容器逃逸」（攻击者突破容器隔离，访问宿主机 / 其他容器），隔离性不如虚拟机的硬件级隔离 💯 资源利用率极高：资源动态分配，容器闲置时资源会释放给宿主机，支持超分（物理机 4G 内存可运行数十个轻量容器），性能损耗极低（1%-5%） 📋 应用兼容性有限：要求应用无状态、可移植，老旧的「重量级应用」（如依赖特定内核模块、专属驱动的应用）难以容器化，需修改代码适配 🔄 环境标准化：「一次构建，到处运行」，容器镜像在开发、测试、生产环境完全一致，彻底解决「开发环境能跑，生产环境跑不了」的问题 🚨 系统特性受限：容器内无法修改宿主机内核参数，无法安装与宿主机内核冲突的驱动 / 模块，部分系统级操作被限制 📦 易运维 / 易扩展：容器镜像可版本化、可追溯，支持 CI/CD 流水线无缝集成，结合 K8s 可实现容器的自动化扩缩容、故障自愈，适配 DevOps / 云原生 📈 网络 / 存储复杂度：容器的动态创建 / 销毁导致网络、存储的管理复杂度升高，需专门的网络插件（如 Calico）、存储插件（如 CSI）支撑 3. 虚拟机和容器的对比 对比维度 虚拟机（VM） 容器（Container） 虚拟化层级 硬件层（物理硬件抽象） 操作系统层（内核资源抽象） 内核归属 每个虚拟机有独立的内核（Guest OS） 所有容器共享宿主机内核，无独立内核 资源分配方式 预先分配，独占配额，闲置不释放 动态分配，按需使用，闲置释放给宿主机 启动速度 分钟级（需加载完整 OS） 毫秒 / 秒级（仅启动进程） 镜像 / 系统体积 GB 级（含完整 OS、内核、库） MB 级（仅含应用 + 依赖，共享基础层） 隔离性 硬件级隔离，极强，彼此无感知 进程级隔离，较强，基于 Linux 内核特性，存在逃逸风险 性能损耗 5%-20%（Type1 低，Type2 高） 1%-5%，几乎可忽略（Linux 宿主机） 资源利用率 低，资源独占，易闲置浪费 极高，支持超分，可运行数十 / 上百个轻量容器 OS 支持 支持任意异构 OS（Windows/Linux/macOS） 仅支持与宿主机内核兼容的 OS，Linux 为主，Windows 需特殊适配 核心实现技术 Hypervisor（KVM/ESXi/VirtualBox） Linux 内核（Namespaces/cgroups/UnionFS）+ 运行时（containerd/runc） 运维复杂度 高，每个 VM 独立维护（更新 / 打补丁） 低，镜像版本化，一次构建到处运行，集群可自动化编排 代表工具 VMware ESXi/KVM/VirtualBox/Hyper-V Docker/containerd/K8s/Docker Compose/Podman 4. Docker docker是容器的一个具体实现，也是容器生态最好的产品，其主要包含docker cli和docker引擎，当我们使用docker客户端工具执行相关命令时，其会将我们的指令分析之后传递给docker引擎并执行。\ndockers客户端可以与引擎在统一主机，也可以不在同一个主机下 ，通过网络进行连接。\n上述图片描述了docker客户端和引擎部分实现细节。\n","date":"2026年01月29日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/posts/docker/what-is-docker/","summary":"\u003ch1 id=\"什么是docker\"\u003e什么是Docker\u003c/h1\u003e\n\u003cp\u003e在学习\u003ccode\u003eDocker\u003c/code\u003e之前先要了解一下虚拟机和容器。\u003c/p\u003e\n\u003cp\u003e虚拟机和容器是两种核心的虚拟化技术，核心目标都是实现\u003cstrong\u003e资源隔离与环境标准化\u003c/strong\u003e，但二者的虚拟化层级、实现原理、资源占用、隔离性天差地别。\u003c/p\u003e","tags":null,"title":"What Is Docker"},{"categories":null,"contents":" ","date":"2026年01月24日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/software-development-parttern/hand-on-dependency-injection-in-go/never-stop-adming-for-better/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003c/div\u003e\n            \u003c/div\u003e\n        \n    \u003c/div\u003e\n\u003c/div\u003e","tags":null,"title":"never-stop-adming-for-better"},{"categories":null,"contents":" 接口 面向接口编程，面向接口编程，面向接口编程\n解耦： 解耦意味着减少组件之间及其所使用数据类型之间的依赖关系。进而提升程序的正确性、质量及可维护性。\n接口使我们能够根据数据的功能将其归类组合。重点在于数据具备何种功能，而非数据本身是什么。用户可以通过接口来获取具体的数据的方式，让代码免受变化的影响，也就是说无论我们底层的实现如何改变，调用方是不会感知到变化的，只要行为没有变化即可。\n接口应描述行为而非状态，应该是动词而非名词。\n在以下情况下使用接口：\nAPI的使用者需要提供实现细节 API有多种实现方式，相关方需要在内部维护这些实现细节 已确定API中可发生变化的部分，这些部分需要进行解耦处理。 在一下情况下不要使用接口：\n为了使用接口而使用接口。 对算法进行泛化处理。 当用户能够定义自己的接口时。 如果不清楚该接口时如何让代码更优化的。 接口毫无价值。 接口是无值类型，他只规定了一组方法，具体数据必须实现这些方法才能满足接口的要求。接口本身没有任何具体内容。\ntype Reader interface{ Read(b []byte)(int,error) } func main(){ var r Reader } 像上述的r变量在没有对它进行赋值实现该接口的类型实例之前，该变量没有任何意义，其为nil。\n我们从不处理接口值，只处理具体值。接口具有编译器层面的表现形式（内部类型），但从我们的编程模型来看，接口本身是无价值的。\n多态性\n多态性是指代码的行为会根据其处理的具体数据而发生变化。\ntype Mover interface { Move() } type Jumper interface { Jump() } type NormalPerson struct{} func (n NormalPerson) Move() { fmt.Println(\u0026#34;我正以每小时5公里的速度前进\u0026#34;) } func (n NormalPerson) Jump() { fmt.Println(\u0026#34;我每次跳跃30cm\u0026#34;) } type AthlecticPerson struct{} func (a AthlecticPerson) Move() { fmt.Println(\u0026#34;我正以每小时10公里的速度前进\u0026#34;) } func (a AthlecticPerson) Jump() { fmt.Println(\u0026#34;我每次跳跃60cm\u0026#34;) } // 定义一个多态函数 func OperatePersonMove(mover Mover) { mover.Move() } 比如上述代码，我想操作不同的人物进行移动或者跳跃，由于不同类型的人物的行为都为走或者跳跃，但是其具体行为细节是不一样，但是我操作人物具体逻辑是一样的，所以OperatePersonMove函数参数为一个Mover接口类型，这里我需要传递的类型不是接口类型，而是实现该接口的具体类型实例。这样在调用Move函数的时候根据不同的具体类型会产生不同的移动效果。\n","date":"2026年01月24日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/notes/golang-notes/ultimate-go-notebook/decoupling/interface/","summary":"\u003cdiv class=\"note-card \"\u003e\n    \u003cdiv class=\"item\"\u003e\n        \u003ch5 class=\"note-title\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/h5\u003e\n        \n            \u003cdiv class=\"card\"\u003e\n                \u003cdiv class=\"card-body\"\u003e\u003ch1 id=\"接口\"\u003e接口\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e面向接口编程，面向接口编程，面向接口编程\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e解耦： 解耦意味着减少组件之间及其所使用数据类型之间的依赖关系。进而提升程序的正确性、质量及可维护性。\u003c/p\u003e","tags":null,"title":"interface"},{"categories":null,"contents":"配置评论功能 hugo是生成静态资源的软件，所以没有后台程序去存储用户评论的数据，所以可以采用云端存储用户数据，但为了简单也可以直接使用giscus。\ngiscus利用Github Discussions实现评论系统的，让方可借助Github在你的网站留下评论的。也就是说你的每一个文章下面的评论都在Github上对应的文件下都有相应的平。而giscusj就是使用Github Discussions搜索API根据选定的映射方式比如url、pathname、title等方式来查找当前页面关联的discussion。\n1. 在GitHub上安装giscus app ❗❗❗在安装giscus app之前需要确定你的仓库是公开的，否则访客是无法查看discussion的。\n打开https://github.com/apps/giscus ，然后选择Install\n当然你也可以根据自己需求选择上述的选项，一般是选择 特定repository。\n记得勾选严格匹配，不然会出现模糊查询过程中只要前缀相似的，都归为一篇文章了。血的教训。。。\n安装完成之后你就可以在Github Settings中Applications中查看到giscus。或者你的repository中Integrations部分可以查看Github Apps是否存在gscus。\n2.配置giscus 2.1 开启discussions功能 打开你的repository settings 然后在General中下滑，找到Features\n在Fetures中找到Discussions然后勾选。\n2.2在giscus官网配置giscus 打开https://giscus.app/zh-CN ，然后在该网站的配置部分中配置discus。\n当你根据上面的配置信息配置完成之后，就可以将\n类似于下面的代码\n放置到你的博客中你想存放的位置，当然一些主题是支持giscus的，所以直接在hugo.yml配置文件中配置即可。\n我是使用的toha主题，所以接下来将我的配置信息做个参考：\n此时有关评论的评论功能就已经全部完成了，接下来运行hugo server -D 来查看是否配置成功。如果出现类似于下面的结果，那就证明配置成功了，如果没有出现，检查一下配置文件是否正确，并且在GitHub上开启了discussions，并且你的repository是否是公开的。\n3. 结尾 ​\t当我们在你的博客文章下面评论了之后，你不仅仅可以在博客页面查看到该评论，还会在你的GitHub上可以查看，而且如果有人评论了你的文章，你会收到GitHub的邮件通知，当然你不想GitHub通知你你也可以选择关闭。\n在Github上查看\n如果你想关闭邮件通知，可以在你的repostory主页，点击watch然后选择custom，选择你想要接受到的通知。\n","date":"2026年01月12日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/posts/deploy-hugo-blog/deploy-comment/","summary":"\u003ch1 id=\"配置评论功能\"\u003e配置评论功能\u003c/h1\u003e\n\u003cp\u003ehugo是生成静态资源的软件，所以没有后台程序去存储用户评论的数据，所以可以采用云端存储用户数据，但为了简单也可以直接使用giscus。\u003c/p\u003e\n\u003cp\u003egiscus利用Github Discussions实现评论系统的，让方可借助Github在你的网站留下评论的。也就是说你的每一个文章下面的评论都在Github上对应的文件下都有相应的平。而giscusj就是使用Github Discussions搜索API根据选定的映射方式比如url、pathname、title等方式来查找当前页面关联的discussion。\u003c/p\u003e","tags":null,"title":"giscus作为hugo博客的评论系统"},{"categories":null,"contents":"将hugo创建的博客使用GitHub Pages发布网站 指定Repository name为 \u0026lt;your_github_username\u0026gt;.github.io 这是必须，不然GitHub Pages没有办法运行你的博客页面。\n接下来在创建gh-pages分支：\n​\t首先告诉你为什么要创建gh-pages分支\n由于我们需要将hugo创建的博客根目录发布到main分支上，但是该目录Github Pages是没办法直接将该部分内容发布到\u0026lt;your_github_username\u0026gt;.github.io网站上去的。只有该目录下的public才能让Github Pages识别到你的网站上。 当然也可以直接将public目录上传到main分支上，不创建gh-pages分支，但是这么做有一个缺点就是，你网站的根目录配置文件，主题文件等内容都没有托管到Github上，你只能依赖你本地的项目去发布文章，修改网页，如果你换了 最重要的是配置文件主题等内容与发布内容分离，main分支主要是hugo以及文章主题的内容，而gh-pages分支就是保存hugo根据你的配置数据等内容产生的静态文件。 所以这也是为什么要再创建一个gh-pages分支，让gh-pages分支存储public所有内容，这个内容是由Github Pages自动完成，每当我们提交新的内容到main分支之后，Github Pages会安装hugo，下载相关资源后然后使用hugo生成public目录到gh-pages分支，然后Github Pages会自动部署gh-pages分支的内容到.github.io网页上。\n创建gh-pages分支\n# 创建gh-pages分支 git checkout -b gh-pages #这块最好是在项目搭建最开始，这样我们的gh-pages分支是干净的什么都没有，如果根目录已经有文件了 也没事直接add即可 git add . git commit -m \u0026#34;添加分支\u0026#34; #将当前根目录push到Github上面 git push -u origin gh-pages 创建自动化部署文件\n在根目录创建.github目录，在.github目录创建workflows目录，在workflows目录下创建deploy.yml文件\n然后将下方内容复制到你的deploy.ymml文件中\nname: Deploy to Github Pages # run when a commit is pushed to \u0026#34;source\u0026#34; branch on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: # checkout to the commit that has been pushed - uses: actions/checkout@v4 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Update Hugo Modules run: hugo mod tidy - name: Setup Node uses: actions/setup-node@v4 with: node-version: 20 - name: Install node modules run: | hugo mod npm pack npm install - name: Build run: hugo --minify # push the generated content into the `gh-pages` branch. - name: Deploy uses: peaceiris/actions-gh-pages@v4 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: gh-pages publish_dir: ./public 然后将该目录上传到你的main分支下。\ngit add . git commit -m \u0026#34;添加自动化部署文件\u0026#34; git push -u origin main 然后配置Github Action权限\n之后直接修改任意文件，然后上传到你的main分支下，然后打开action，查看是否正在部署。\n如果出现部署失败，不要慌，直接点击进去，看哪里出现问题了，然后直接复制到ai下面，问一下。现在ai能解决你大部分问题。\n到这里就部署完成了，然后就是根据不同主题，修改相应的配置优化网站了~~~~~\n","date":"2026年01月12日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/posts/deploy-hugo-blog/deploy-to-github/","summary":"\u003ch1 id=\"将hugo创建的博客使用github-pages发布网站\"\u003e将hugo创建的博客使用GitHub Pages发布网站\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/deploy-hugo-blog/deploy-to-github/image-20260112045208111.png\" alt=\"image-20260112045208111\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cfont color=\"  #BA55D3\"\u003e\u003cb\u003e指定Repository name为 \u0026lt;your_github_username\u0026gt;.github.io\u003c/b\u003e\u003c/font\u003e 这是必须，不然GitHub Pages没有办法运行你的博客页面。\u003c/p\u003e\n\u003cp\u003e接下来在创建gh-pages分支：\u003c/p\u003e","tags":null,"title":"部署到Github"},{"categories":null,"contents":"hugo安装主题 在安装主题之前，你需要下载git,node.js\n接下来有关主题的安装，以及发布到Github Pages上都是默认安装了git、node.js。\n选择主题 当我们成功创建了我们的博客网站，接下来就是选择一个你喜欢的主题。\n可以从hugo官方网站https://themes.gohugo.io/上选择主题，也可以从搜索引擎上搜“hugo 主题”找到一款你中意的主题。\n接下来我们都是以hugo官网上推荐的toha主题作为例子来讲解如何安装主题，并且发布到Github Pages上。\n安装toha 我们打开https://themes.gohugo.io/\n选择toha主题\n点击demo\n查看toha官方文档\n选择Quickstart跟着做即可\n这里需要注意的是，如果你希望你的blog项目托管到Github Pages上，建议在安装主题之前，先创建好GitHub Repository。\n然后将Repository name设置为\u0026lt;your_github_name\u0026gt;.github.io格式。\n之后点击创建即可，然后将你创建好website项目的根目录 下执行下面的命令：\ngit add . git commit -m \u0026#34;初始化项目\u0026#34; git branch -M main git remote add origin git@github.com:\u0026lt;your_username\u0026gt;/\u0026lt;your_username\u0026gt;.github.com.git git push -u origin main 安装toha theme有两种安装方法，这里只介绍其中一个：\n直接下载主题到/themes/目录下\ngit clone https://github.com/hugo-themes/toha ./themes/ 查看目录是否存在toha\n如果存在接下来就是执行下面的命令：\nhugo mod init github.com/\u0026lt;your user name\u0026gt;/\u0026lt;your repo name\u0026gt; 然后修改hugo.yaml 配置文件：\n如果执行使用hugo new web-site命令，其默认的配置文件是tmol文件，所以我们先将该文件名改为hugo.tmol.backup。然后创建一个名为hugo.yaml文件。并且将下面的内容复制到hugo.yaml文件中\nbaseURL: https://foreverool.github.io/ # 这里需要填写你自己的github 上的repository 名称 languageCode: zh-cn title: \u0026#34;foreverool\u0026#39;s blog\u0026#34; timeZone: \u0026#34;Asia/Shanghai\u0026#34; # 中国标准时间（UTC+8），解决时间显示偏移问题 theme: \u0026#34;toha\u0026#34; defaultContentLanguage: zh-cn module: mounts: - source: ./node_modules/flag-icon-css/flags target: static/flags - source: ./node_modules/@fontsource/mulish/files target: static/files - source: ./node_modules/katex/dist/fonts target: static/fonts 做完上面的操作，接下来执行关键步骤：\n# download the theme hugo mod get -u # download the theme\u0026#39;s dependencies hugo mod tidy # generate node dependencies hugo mod npm pack # install install dependencies npm install 执行完这些，你的项目目录下会有node_modules目录。如果没有重新执行上述命令。\n接下来执行hugo server -w命令 看是否能正常运行，如果不能，记得安装hugo extended 。\n到这里目前主题已经安装完成了，其他有关主题的详细配置，toha官方写会更加详细，如果英文阅读能力稍微差点的，可以直接右键选择翻译该网站即可。\n","date":"2026年01月11日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/posts/deploy-hugo-blog/install-theme/","summary":"\u003ch1 id=\"hugo安装主题\"\u003ehugo安装主题\u003c/h1\u003e\n\u003cp\u003e在安装主题之前，你需要下载\u003ccode\u003egit\u003c/code\u003e,\u003ccode\u003enode.js\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e接下来有关主题的安装，以及发布到Github Pages上都是默认安装了git、node.js。\u003c/p\u003e","tags":null,"title":"安装主题"},{"categories":null,"contents":"hugo个人博客搭建 在使用hugo搭建个人博客之前，我们需要明确知道hugo是一种生成静态文件的博客软件。它没有与数据库这种存储用户数据的软件进行搭配，而是将我们的文章转换成静态网页的形式发布的。\n该篇文章所有的安装过程都是在windows上\n1. 下载与安装hugo 1.1 下载 如果你使用了其它系统，可以参考hugo官网https://gohugo.io/installation\n在windows下安装hugo个人建议直接在https://github.com/gohugoio/hugo/releases/tag/v0.154.4下载安装包，这里要注意官方提供了很多不同的压缩包，建议安装扩展版也就是安装包中包含extended，这里主要是方便你后续选择不同的hugo主题的时候可以正常使用这些主题。extended就是hugo的扩展，包含了更多的内容。\n1.2 安装 这个安装步骤其实准确来说是将下载好的压缩包解压，解压完成后，你会得到hugo.exe软件，然后将该软件所在的目录添加到用户的环境变量中，这样就可以直接在命令行中使用hugo。\n对于不知道如何设置环境变量的同学，请看接下来的操作，如果知道的同学直接看第二部分。\n设置环境变量\nwindows 11\n打开设置，找到系统\n然后点击系统，拉到最下面，找到系统信息，并且点击\n然后找到高级系统设置\n之后点击环境变量\n在用户那里找到path\n双击path，然后将hugo所在的目录复制到path那里就可以了\n之后打开cmd看是否可以执行hugo，如果不能执行直接重启，然后就可以了。\n这也是有时候我们设置完环境变量不能立马直接某些程序的解决方法之一。\n2. 创建网站（博客） 如果在命令行可以正常使用hugo ，那么执行下面的命令:\nhugo new site your-website-name 这个命令主要是创建你的网站的骨架，此时还没有任何网站主题和相关内容。\n在创建完网站骨架之后，你可以在命令行切换到your-website-name目录下，然后执行：\n# 切换到刚才使用hugo创建的项目根目录下 Z:\\blog\u0026gt;cd demo-website #然后执行 hugo server -D 如果出现下面这样的内容，就证明你的网站骨架创建成功了，接下来就是选择主题了\n之后想要查看你的网站内容的话，按住ctrl 并且点击上面的localhost地址就可以直接访问\n此时下载与安装基本已经完成了，接下来就是配置主题了。请看下一篇文章~\n","date":"2026年01月11日","hero":"/images/posts/deploy-hugo-blog/images.png","permalink":"https://foreverool.github.io/posts/deploy-hugo-blog/install/","summary":"\u003ch1 id=\"hugo个人博客搭建\"\u003ehugo个人博客搭建\u003c/h1\u003e\n\u003cp\u003e在使用hugo搭建个人博客之前，我们需要明确知道hugo是一种生成静态文件的博客软件。它没有与数据库这种存储用户数据的软件进行搭配，而是将我们的文章转换成静态网页的形式发布的。\u003c/p\u003e","tags":null,"title":"下载安装hugo"},{"categories":null,"contents":"chan的实现原理 0. 预备知识 0.1 Unix管道 ​\t在Unix以及类Unix操作系统中，管道(pipeline)是将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入，也就是说管道其实是进程间的通信机制。\n​\t管道的典型用途是为两个不同进程（一个父进程，另一个是子进程）间进行通信的手段。首先会根据父进程fork（unix创建子进程的函数）一个子进程（也就是创建一个父进程的副本），由于创建管道会返回两个文件描述符，一个是读描述符，另一个是写描述符。在进行fork的时候，进程空间会进行复制，也就是说该文件描述符也会被复制，所有两个进程都有相同的读写文件描述符。\n​\t当父进程关闭读出端，子进程关闭同一管道的写入端。这样就在父子进程间提供了一个单向数据流。\n​\t比如在执行linux命令时：\nls -l | grep \u0026#34;chan\u0026#34; ​\t首先父进程就是shell，它首先会创建管道(pipe)，\n接着创建ls 子进程，之后创建grep子进程，也就是fork两个子进程，这样两个子进程就会包含管道返回的两个文件描述符，之后将ls -l所执行的命令标准输出写入到管道之中，然后grep \u0026quot;chan\u0026quot;则会从管道读取数据并处理，最后就是返回结果。\n0.1.1 管道在linux下的具体实现 ​\t管道在Linux系统具体实现是缓冲区buffer而不是队列。\n​\t管道会为读端和写端分别分配内核缓冲区， 写进程将数据写入写端缓冲区，读进程从读端缓冲区读取数据。内核将写端缓冲区的数据进行复制到读端缓冲区，然后内核也会维护读写两端的位置指针。\n​\t同步机制：\n​\t当写端缓冲区满的时候，写进程会被阻塞掉，直到读进程读取了部分数据腾出空间。\n​\t当读缓冲区为空的时候，读进程会被阻塞，直到写进程写入了新数据。\n​\t管道的数据采用FIFO的数据处理模式，也就是先写入的数据先被读取。\n1. chanel ​\t在go语言中，一个进程可能会有多个goroutine，多个goroutine之间的通信可以使用chanel或者对于共享内存进行加锁。\n1.1 chan的数据结构 ​\t在go SDK 1.20.3 中的runtime/chan.gp文件中就定义了chan的底层数据结构hchan。\ntype hchan struct{ qcount uint // 表示当前队列中的剩余元素 dataqsiz uint\t// 表示循环队列的大小，即可以存放元素的个数 buf unsafe.Pointer\t// 指向一个dataqsiz大小的数组，也就是环形队列的指针 elemsize uint16\t// 每个元素的大小 closed uint32\t// 标记关闭状态 elemtype *_type\t// 元素类型 sendx uint\t// 队列下标，指元素写入时存放到队列中的位置 recvx uint\t// 队列下标，指元素从队列的该位置读出 recvq waitq\t// 等待读消息的goroutine队列 sendq waitq\t// 等待写消息的goroutine队列 lcok mutex\t// 互斥锁，chan不允许并发读写 } type waitq struct { first *sudog last *sudog } ​\twaitg类型是一个队列，其包含队列的第一个元素指针和最后一个元素指针。\n​\twaitq实现了两个方法分别是: enqueue, dequeue。\ntype sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack) // The following fields are never accessed concurrently. // For channels, waitlink is only accessed by g. // For semaphores, all fields (including the ones above) // are only accessed when holding a semaRoot lock. acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so // g.selectDone must be CAS\u0026#39;d to win the wake-up race. isSelect bool // success indicates whether communication over channel c // succeeded. It is true if the goroutine was awoken because a // value was delivered over channel c, and false if awoken // because c was closed. success bool parent *sudog // semaRoot binary tree waitlink *sudog // g.waiting list or semaRoot waittail *sudog // semaRoot c *hchan // channel } sudog:用于表示一个在等待列表的g(表示goroutine 的数据结构)。\n思考： 为什么需要sudog而不是直接使用g？\n​\tgo SDK中作者表示：\n// sudog is necessary because the g ↔ synchronization object relation // is many-to-many. A g can be on many wait lists, so there may be // many sudogs for one g; and many gs may be waiting on the same // synchronization object, so there may be many sudogs for one object. ​\t总结：sudog的存在是必须的，因为goroutine和同步对象之间的关系是多对多的。一个goroutine可以在多个等待列表当中，因此多个sudog表示同一个goroutine，并且多个goroutine可能等待同一个同步对象，所以有个同步对象有多个sudog。\n1.1.1 环形队列 ​\tchan内部实现了一个环形队列的缓冲区，也就是buf字段，队列的长度是在创建chan的时候指定，也就是使用make函数创建的时候指定的，如果不指定长度，则没有这个环形缓冲区，也就是无缓冲chan。\n1.1.2 等待队列 ​\t一个goroutine从chanel读数据，如果chanel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。\n​\t一个goroutine从chanel写数据，如果chanel缓冲区满了或者没有缓冲区，当前goroutine会被阻塞。\n​\t被阻塞的goroutine会被存储在等待队列当中，也就是recvq， sendq当中。\n​\tsendq队列用于存储那些试图向chanel发送数据但被阻塞的goroutine。\n​\trecvq队列用于存储那些试图向chanel读取数据但被阻塞的goroutine。\n思考： 当多个读goroutine被阻塞，然后存储在recvq等待队列当中，此时有一个写goroutine写入数据，那么唤醒所有等待队列的goroutine还是唤醒部分？\n​\t答: chanel不会唤醒所有等待队列的goroutine，会取出一个goroutine处理数据，因为chanel的设计是尽可能高效地完成数据的传递，如果每次读取都唤醒所有的recvq中的goroutine会导致大量无谓的上下文切换，降低性能。选择队列头部的goroutine来传输数据，可以保证FIFO的顺序，避免饥饿问题的发生。\n1.1.3 类型信息 ​\t一个chanel只能传递一种类型的值，类型信息存储在hchan当中【elemtype. elemsize】\n1.1.4 锁 ​\t一个chanel同时仅允许被一个goroutine读写。这也是为什么chanel是线程安全的数据类型。\n1.2 向chanel中写数据 code\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { if !block { return false } gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } if debugChan { print(\u0026#34;chansend: chan=\u0026#34;, c, \u0026#34;\\n\u0026#34;) } if raceenabled { racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend)) } // Fast path: check for failed non-blocking operation without acquiring the lock. // // After observing that the channel is not closed, we observe that the channel is // not ready for sending. Each of these observations is a single word-sized read // (first c.closed and second full()). // Because a closed channel cannot transition from \u0026#39;ready for sending\u0026#39; to // \u0026#39;not ready for sending\u0026#39;, even if the channel is closed between the two observations, // they imply a moment between the two when the channel was both not yet closed // and not ready for sending. We behave as if we observed the channel at that moment, // and report that the send cannot proceed. // // It is okay if the reads are reordered here: if we observe that the channel is not // ready for sending and then observe that it is not closed, that implies that the // channel wasn\u0026#39;t closed during the first observation. However, nothing here // guarantees forward progress. We rely on the side effects of lock release in // chanrecv() and closechan() to update this thread\u0026#39;s view of c.closed and full(). if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { return false } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } if sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } if c.qcount \u0026lt; c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. qp := chanbuf(c, c.sendx) if raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ unlock(\u0026amp;c.lock) return true } if !block { unlock(\u0026amp;c.lock) return false } // Block on the channel. Some receiver will complete our operation for us. gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we\u0026#39;re about // to park on a channel. The window between when this G\u0026#39;s status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. gp.parkingOnChan.Store(true) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) // Ensure the value being sent is kept alive until the // receiver copies it out. The sudog has a pointer to the // stack object, but sudogs aren\u0026#39;t considered as roots of the // stack tracer. KeepAlive(ep) // someone woke us up. if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) if closed { if c.closed == 0 { throw(\u0026#34;chansend: spurious wakeup\u0026#34;) } panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } return true } 向一个chanel写入数据的具体实现过程：\n检查chanel的状态\n首先检查chanel的状态，包括是否已关闭、是否缓冲区满了。\n尝试直接发送\n如果chanel不满且有等待接收的goroutine，则会直接将数据发送给等待的goroutine，并唤醒该goroutine。\n如何发送数据\nif sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } 根据源码我们可以看出如果recvq等待队列中有读goroutine（不为空的情况下），从该队列出队获取到一个goroutine然后发送数据。由于recvq不为空，也就是说chanel中的buf环形队列中没有数据，此时就直接发送数据就可以了。\n// send processes a send operation on an empty channel c. // The value ep sent by the sender is copied to the receiver sg. // The receiver is then woken up to go on its merry way. // Channel c must be empty and locked. send unlocks c with unlockf. // sg must already be dequeued from c. // ep must be non-nil and point to the heap or the caller\u0026#39;s stack. func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if raceenabled { if c.dataqsiz == 0 { racesync(c, sg) } else { // Pretend we go through the buffer, even though // we copy directly. Note that we need to increment // the head/tail locations only when raceenabled. racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } } if sg.elem != nil { sendDirect(c.elemtype, sg, ep) sg.elem = nil } gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) { // src is on our stack, dst is a slot on another stack. // Once we read sg.elem out of sg, it will no longer // be updated if the destination\u0026#39;s stack gets copied (shrunk). // So make sure that no preemption points can happen between read \u0026amp; use. dst := sg.elem typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size) // No need for cgo write barrier checks because dst is always // Go memory. memmove(dst, src, t.size) } 未完待续\u0026hellip;.\n","date":"2026年01月10日","hero":"/images/default-hero.jpg","permalink":"https://foreverool.github.io/posts/golang/chanel-base/","summary":"\u003ch1 id=\"chan的实现原理\"\u003echan的实现原理\u003c/h1\u003e\n\u003chr\u003e\n\u003ch1 id=\"0-预备知识\"\u003e0. 预备知识\u003c/h1\u003e\n\u003ch3 id=\"01-unix管道\"\u003e0.1 Unix管道\u003c/h3\u003e\n\u003cp\u003e​\t在\u003ccode\u003eUnix\u003c/code\u003e以及类\u003ccode\u003eUnix\u003c/code\u003e操作系统中，管道(pipeline)是将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入，也就是说管道其实是进程间的通信机制。\u003c/p\u003e","tags":null,"title":"Chanel Base"}]