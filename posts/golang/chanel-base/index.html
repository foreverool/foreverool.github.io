<!doctype html><html lang=zh-cn><head><title>Chanel Base</title><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/cal-heatmap@4.2.3/dist/cal-heatmap.min.css crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/cal-heatmap@4.2.3/dist/cal-heatmap.min.js crossorigin=anonymous></script><link rel=stylesheet href=/application.af889ef4e7baffa6d3a1567e26c1e3e34d28dff131d847f0a86ac53100aa9921.css integrity="sha256-r4ie9Oe6/6bToVZ+JsHj400o3/Ex2EfwqGrFMQCqmSE="><link rel=icon type=image/png href=/images/favicon_hu_c56d8f99d6baf5c5.png><meta property="og:title" content="foreverool's blog"><meta property="og:type" content="website"><meta property="og:description" content="foreverool 的博客"><meta property="og:image" content="/images/avatar2.png"><meta property="og:url" content="https://foreverool.github.io/"><meta name=description content="Chanel Base"><script integrity="sha256-DO4ugzEwhTW1Id1UIWn0gUJWaebCYOypeTit6LW4QB4=">let theme=localStorage.getItem("theme-scheme")||localStorage.getItem("darkmode:color-scheme")||"light";theme==="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?theme="dark":theme="light"),document.documentElement.setAttribute("data-theme",theme)</script></head><body class="type-posts kind-page" data-bs-spy=scroll data-bs-target=#TableOfContents data-bs-offset=80><div class="container-fluid bg-secondary wrapper"><nav class="navbar navbar-expand-xl top-navbar shadow" id=top-navbar><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<i data-feather=sidebar></i>
</button>
<a class=navbar-brand href=/><img src=/images/main-logo_hu_b4ca8dcb406ed5a7.png id=logo alt=Logo>
foreverool's blog</a>
<button class="navbar-toggler navbar-light" id=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#top-nav-items aria-label=menu>
<i data-feather=menu></i></button><div class="collapse navbar-collapse dynamic-navbar" id=top-nav-items><ul class="nav navbar-nav ms-auto"><li class=nav-item><a class=nav-link href=/#home>主页</a></li><li class=nav-item><a class=nav-link href=/#featured-posts>精选文章</a></li><li class=nav-item><a class=nav-link href=/#about>About</a></li><li class=nav-item><a class=nav-link href=/#recent-posts>最新发布</a></li><li class=nav-item><a class=nav-link href=/#projects>Projects</a></li><div id=top-navbar-divider></div><li class=nav-item><a class=nav-link id=blog-link href=/posts>文章</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=themeSelector role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false><img id=navbar-theme-icon-svg class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme"></a><div id=themeMenu class="dropdown-menu dropdown-menu-icons-only" aria-labelledby=themeSelector><a class="dropdown-item nav-link" href=# data-scheme=light><img class=theme-icon src=/icons/sun-svgrepo-com.svg width=20 alt="Light Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=dark><img class=theme-icon src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=system><img class=theme-icon src=/icons/computer-svgrepo-com.svg width=20 alt="System Theme"></a></div></li></ul></div></div><img src=/images/main-logo_hu_b4ca8dcb406ed5a7.png class=d-none id=main-logo alt=Logo>
<img src=/images/inverted-logo_hu_3aa5006eac892b40.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=搜索 data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts/ data-filter=all>文章</a></li><div class=subtree><li><i data-feather=minus-circle></i><a class="active list-link" href=/posts/golang/> Golang</a><ul class=active><li><a class="active list-link" href=/posts/golang/chanel-base/ title="Chanel Base">Chanel Base</a></li></ul></li><li><i data-feather=plus-circle></i><a class=list-link href=/posts/deploy-hugo-blog/> 搭建hugo博客</a><ul><li><a class=list-link href=/posts/deploy-hugo-blog/install/ title=下载安装hugo>下载安装hugo</a></li><li><a class=list-link href=/posts/deploy-hugo-blog/install-theme/ title=安装主题>安装主题</a></li><li><a class=list-link href=/posts/deploy-hugo-blog/deploy-to-github/ title=部署到Github>部署到Github</a></li><li><a class=list-link href=/posts/deploy-hugo-blog/deploy-comment/ title=使用giscus作为hugo博客的评论系统>使用giscus作为hugo博客的评论系统</a></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(/images/default-hero.jpg)></div><div class=page-content><div class="author-profile ms-auto align-self-lg-center"><img class=rounded-circle src=/images/avatar2_hu_7852a7e25db64f97.png alt="Author Image"><h5 class=author-name>foreverool</h5><p class=text-muted>发布于 2026年1月10日 | 7 分钟</p></div><div class=title><h1>Chanel Base</h1></div><div class=tags><ul style=padding-left:0></ul></div><div class=post-content id=post-content><h1 id=chan的实现原理>chan的实现原理</h1><hr><h1 id=0-预备知识>0. 预备知识</h1><h3 id=01-unix管道>0.1 Unix管道</h3><p>​ 在<code>Unix</code>以及类<code>Unix</code>操作系统中，管道(pipeline)是将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入，也就是说管道其实是进程间的通信机制。</p><p>​ 管道的典型用途是为两个不同进程（一个父进程，另一个是子进程）间进行通信的手段。首先会根据父进程<code>fork</code>（<code>unix</code>创建子进程的函数）一个子进程（也就是创建一个父进程的副本），由于创建管道会返回两个文件描述符，一个是读描述符，另一个是写描述符。在进行<code>fork</code>的时候，进程空间会进行复制，也就是说该文件描述符也会被复制，所有两个进程都有相同的读写文件描述符。</p><p><img src=/images/posts/golang/chanel_base/Image00027.jpg alt=img></p><p>​ 当父进程关闭读出端，子进程关闭同一管道的写入端。这样就在父子进程间提供了一个单向数据流。</p><p><img src=/images/posts/golang/chanel_base/Image00028.jpg alt=img></p><p>​ 比如在执行<code>linux</code>命令时：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls -l | grep <span style=color:#e6db74>&#34;chan&#34;</span>
</span></span></code></pre></div><p>​ 首先父进程就是<code>shell</code>，它首先会创建管道(pipe)，</p><p>接着创建<code>ls </code>子进程，之后创建<code>grep</code>子进程，也就是<code>fork</code>两个子进程，这样两个子进程就会包含管道返回的两个文件描述符，之后将<code>ls -l</code>所执行的命令标准输出写入到管道之中，然后<code>grep "chan"</code>则会从管道读取数据并处理，最后就是返回结果。</p><h4 id=011-管道在linux下的具体实现>0.1.1 管道在linux下的具体实现</h4><p>​ 管道在<code>Linux</code>系统具体实现是缓冲区<code>buffer</code>而不是队列。</p><p>​ 管道会为读端和写端分别分配内核缓冲区， 写进程将数据写入写端缓冲区，读进程从读端缓冲区读取数据。内核将写端缓冲区的数据进行复制到读端缓冲区，然后内核也会维护读写两端的位置指针。</p><p>​ 同步机制：</p><p>​ 当写端缓冲区满的时候，写进程会被阻塞掉，直到读进程读取了部分数据腾出空间。</p><p>​ 当读缓冲区为空的时候，读进程会被阻塞，直到写进程写入了新数据。</p><p>​ 管道的数据采用<code>FIFO</code>的数据处理模式，也就是先写入的数据先被读取。</p><hr><h2 id=1-chanel>1. chanel</h2><p>​ 在<code>go</code>语言中，一个进程可能会有多个<code>goroutine</code>，多个<code>goroutine</code>之间的通信可以使用<code>chanel</code>或者对于共享内存进行加锁。</p><h3 id=11-chan的数据结构>1.1 chan的数据结构</h3><p>​ 在<code>go SDK 1.20.3 </code>中的<code>runtime/chan.gp</code>文件中就定义了<code>chan</code>的底层数据结构<code>hchan</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>qcount</span> <span style=color:#66d9ef>uint</span> 		<span style=color:#75715e>// 表示当前队列中的剩余元素</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>dataqsiz</span> <span style=color:#66d9ef>uint</span>		<span style=color:#75715e>// 表示循环队列的大小，即可以存放元素的个数</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>buf</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>	<span style=color:#75715e>// 指向一个dataqsiz大小的数组，也就是环形队列的指针</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>elemsize</span> <span style=color:#66d9ef>uint16</span>		<span style=color:#75715e>// 每个元素的大小</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>closed</span> <span style=color:#66d9ef>uint32</span>		<span style=color:#75715e>// 标记关闭状态</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>elemtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>		<span style=color:#75715e>// 元素类型</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sendx</span> <span style=color:#66d9ef>uint</span>			<span style=color:#75715e>// 队列下标，指元素写入时存放到队列中的位置</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>recvx</span> <span style=color:#66d9ef>uint</span>			<span style=color:#75715e>// 队列下标，指元素从队列的该位置读出</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>recvq</span> <span style=color:#a6e22e>waitq</span>			<span style=color:#75715e>// 等待读消息的goroutine队列</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sendq</span> <span style=color:#a6e22e>waitq</span>			<span style=color:#75715e>// 等待写消息的goroutine队列</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>lcok</span>  <span style=color:#a6e22e>mutex</span>			<span style=color:#75715e>// 互斥锁，chan不允许并发读写</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>waitq</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>first</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>last</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>​ <code>waitg</code>类型是一个队列，其包含队列的第一个元素指针和最后一个元素指针。</p><p>​ <code>waitq</code>实现了两个方法分别是: <code>enqueue, dequeue</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sudog</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The following fields are protected by the hchan.lock of the</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// channel this sudog is blocking on. shrinkstack depends on</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// this for sudogs involved in channel ops.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// data element (may point to stack)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The following fields are never accessed concurrently.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// For channels, waitlink is only accessed by g.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// For semaphores, all fields (including the ones above)</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// are only accessed when holding a semaRoot lock.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>acquiretime</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releasetime</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ticket</span>      <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// isSelect indicates g is participating in a select, so</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// g.selectDone must be CAS&#39;d to win the wake-up race.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>isSelect</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// success indicates whether communication over channel c</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// succeeded. It is true if the goroutine was awoken because a</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// value was delivered over channel c, and false if awoken</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// because c was closed.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>success</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>parent</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// semaRoot binary tree</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>waitlink</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// g.waiting list or semaRoot</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>waittail</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span> <span style=color:#75715e>// semaRoot</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>        <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span> <span style=color:#75715e>// channel</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>sudog</code>:用于表示一个在等待列表的<code>g(表示goroutine 的数据结构)</code>。</p><p>思考： 为什么需要<code>sudog</code>而不是直接使用<code>g</code>？</p><p>​ <code>go SDK</code>中作者表示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// sudog is necessary because the g ↔ synchronization object relation</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// is many-to-many. A g can be on many wait lists, so there may be</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// many sudogs for one g; and many gs may be waiting on the same</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// synchronization object, so there may be many sudogs for one object.</span>
</span></span></code></pre></div><p>​ 总结：<code>sudog</code>的存在是必须的，因为<code>goroutine</code>和同步对象之间的关系是多对多的。一个<code>goroutine</code>可以在多个等待列表当中，因此多个<code>sudog</code>表示同一个<code>goroutine</code>，并且多个<code>goroutine</code>可能等待同一个同步对象，所以有个同步对象有多个<code>sudog</code>。</p><h4 id=111-环形队列>1.1.1 环形队列</h4><p>​ <code>chan</code>内部实现了一个环形队列的缓冲区，也就是<code>buf</code>字段，队列的长度是在创建<code>chan</code>的时候指定，也就是使用<code>make</code>函数创建的时候指定的，如果不指定长度，则没有这个环形缓冲区，也就是无缓冲<code>chan</code>。</p><p><img src=/images/posts/golang/chanel_base/hchan-queue.png alt=hchan-queue></p><h4 id=112-等待队列>1.1.2 等待队列</h4><p>​ 一个<code>goroutine</code>从<code>chanel</code>读数据，如果<code>chanel</code>缓冲区为空或者没有缓冲区，当前<code>goroutine</code>会被阻塞。</p><p>​ 一个<code>goroutine</code>从<code>chanel</code>写数据，如果<code>chanel</code>缓冲区满了或者没有缓冲区，当前<code>goroutine</code>会被阻塞。</p><p>​ 被阻塞的<code>goroutine</code>会被存储在等待队列当中，也就是<code>recvq， sendq</code>当中。</p><p>​ <code>sendq</code>队列用于存储那些试图向<code>chanel</code>发送数据但被阻塞的<code>goroutine</code>。</p><p>​ <code>recvq</code>队列用于存储那些试图向<code>chanel</code>读取数据但被阻塞的<code>goroutine</code>。</p><p><strong>思考： 当多个读<code>goroutine</code>被阻塞，然后存储在<code>recvq</code>等待队列当中，此时有一个写<code>goroutine</code>写入数据，那么唤醒所有等待队列的<code>goroutine</code>还是唤醒部分？</strong></p><p>​ <font color=red>答: <code>chanel</code>不会唤醒所有等待队列的<code>goroutine</code>，会取出一个<code>goroutine</code>处理数据，因为<code>chanel</code>的设计是尽可能高效地完成数据的传递，如果每次读取都唤醒所有的<code>recvq</code>中的<code>goroutine</code>会导致大量无谓的上下文切换，降低性能。选择队列头部的<code>goroutine</code>来传输数据，可以保证<code>FIFO</code>的顺序，避免饥饿问题的发生。</font></p><h4 id=113-类型信息>1.1.3 类型信息</h4><p>​ 一个<code>chanel</code>只能传递一种类型的值，类型信息存储在<code>hchan</code>当中【<code>elemtype. elemsize</code>】</p><h4 id=114-锁>1.1.4 锁</h4><p>​ 一个<code>chanel</code>同时仅允许被一个<code>goroutine</code>读写。这也是为什么<code>chanel</code>是线程安全的数据类型。</p><h4 id=12-向chanel中写数据>1.2 向<code>chanel</code>中写数据</h4><p><strong>code</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanSendNilChan</span>, <span style=color:#a6e22e>traceEvGoStop</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>debugChan</span> {
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>&#34;chansend: chan=&#34;</span>, <span style=color:#a6e22e>c</span>, <span style=color:#e6db74>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>racereadpc</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>(), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>chansend</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Fast path: check for failed non-blocking operation without acquiring the lock.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>	// After observing that the channel is not closed, we observe that the channel is</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// not ready for sending. Each of these observations is a single word-sized read</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// (first c.closed and second full()).</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Because a closed channel cannot transition from &#39;ready for sending&#39; to</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// &#39;not ready for sending&#39;, even if the channel is closed between the two observations,</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// they imply a moment between the two when the channel was both not yet closed</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// and not ready for sending. We behave as if we observed the channel at that moment,</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// and report that the send cannot proceed.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>	// It is okay if the reads are reordered here: if we observe that the channel is not</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ready for sending and then observe that it is not closed, that implies that the</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// channel wasn&#39;t closed during the first observation. However, nothing here</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// guarantees forward progress. We rely on the side effects of lock release in</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// chanrecv() and closechan() to update this thread&#39;s view of c.closed and full().</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>full</span>(<span style=color:#a6e22e>c</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t0</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>blockprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Found a waiting receiver. We pass the value we want to send</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// directly to the receiver, bypassing the channel buffer (if any).</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &lt; <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Space is available in the channel buffer. Enqueue the element to send.</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Block on the channel. Some receiver will complete our operation for us.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// No stack splits between assigning elem and enqueuing mysg</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// on gp.waiting where copystack can find it.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>waitlink</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>isSelect</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Signal to anyone trying to shrink our stack that we&#39;re about</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// to park on a channel. The window between when this G&#39;s status</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// changes and when we set gp.activeStackChans is not safe for</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// stack shrinking.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>parkingOnChan</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>chanparkcommit</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>), <span style=color:#a6e22e>waitReasonChanSend</span>, <span style=color:#a6e22e>traceEvGoBlockSend</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Ensure the value being sent is kept alive until the</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// receiver copies it out. The sudog has a pointer to the</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// stack object, but sudogs aren&#39;t considered as roots of the</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// stack tracer.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>KeepAlive</span>(<span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// someone woke us up.</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>closed</span> <span style=color:#f92672>:=</span> !<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>success</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>closed</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;chansend: spurious wakeup&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>向一个<code>chanel</code>写入数据的具体实现过程：</p><ul><li><p>检查<code>chanel</code>的状态</p><p>首先检查<code>chanel</code>的状态，包括是否已关闭、是否缓冲区满了。</p></li><li><p>尝试直接发送</p><p>如果<code>chanel</code>不满且有等待接收的<code>goroutine</code>，则会直接将数据发送给等待的<code>goroutine</code>，并唤醒该<code>goroutine</code>。</p><ul><li><p>如何发送数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Found a waiting receiver. We pass the value we want to send</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// directly to the receiver, bypassing the channel buffer (if any).</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>根据源码我们可以看出如果<code>recvq</code>等待队列中有读<code>goroutine</code>（不为空的情况下），从该队列出队获取到一个<code>goroutine</code>然后发送数据。由于<code>recvq</code>不为空，也就是说<code>chanel</code>中的<code>buf</code>环形队列中没有数据，此时就直接发送数据就可以了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// send processes a send operation on an empty channel c.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The value ep sent by the sender is copied to the receiver sg.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The receiver is then woken up to go on its merry way.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Channel c must be empty and locked.  send unlocks c with unlockf.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// sg must already be dequeued from c.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ep must be non-nil and point to the heap or the caller&#39;s stack.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>skip</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>racesync</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Pretend we go through the buffer, even though</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// we copy directly. Note that we need to increment</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// the head/tail locations only when raceenabled.</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>, <span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#75715e>// c.sendx = (c.sendx+1) % c.dataqsiz</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sendDirect</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unlockf</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>skip</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sendDirect</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>src</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// src is on our stack, dst is a slot on another stack.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Once we read sg.elem out of sg, it will no longer</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// be updated if the destination&#39;s stack gets copied (shrunk).</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// So make sure that no preemption points can happen between read &amp; use.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dst</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typeBitsBulkBarrier</span>(<span style=color:#a6e22e>t</span>, uintptr(<span style=color:#a6e22e>dst</span>), uintptr(<span style=color:#a6e22e>src</span>), <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// No need for cgo write barrier checks because dst is always</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Go memory.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>src</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>未完待续&mldr;.</p></li></ul></li></ul></div><div class="row ps-3 pe-3"><div class="col-md-6 share-buttons"></div></div><hr><div class="row next-prev-navigator"><div class="col-md-12 next-article"><a href=/posts/deploy-hugo-blog/install/ title=下载安装hugo class="btn filled-button"><div>下一篇 <i class="fas fa-chevron-circle-right"></i></div><div class=next-prev-text>下载安装hugo</div></a></div></div><hr><script src=https://giscus.app/client.js data-repo=foreverool/foreverool.github.io data-repo-id=R_kgDOQ37o_Q data-category=Announcements data-category-id=DIC_kwDOQ37o_c4C02rS data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang data-strict=1 data-loading=lazy crossorigin=anonymous async></script></div></div></div><a id=scroll-to-top class=btn type=button data-bs-toggle=tooltip data-bs-placement=left title="Scroll to top"><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center ps-3">目录</h5><hr><div class=toc><nav id=TableOfContents><ul><li><ul><li><a href=#01-unix管道>0.1 Unix管道</a><ul><li><a href=#011-管道在linux下的具体实现>0.1.1 管道在linux下的具体实现</a></li></ul></li></ul></li><li><a href=#1-chanel>1. chanel</a><ul><li><a href=#11-chan的数据结构>1.1 chan的数据结构</a><ul><li><a href=#111-环形队列>1.1.1 环形队列</a></li><li><a href=#112-等待队列>1.1.2 等待队列</a></li><li><a href=#113-类型信息>1.1.3 类型信息</a></li><li><a href=#114-锁>1.1.4 锁</a></li><li><a href=#12-向chanel中写数据>1.2 向<code>chanel</code>中写数据</a></li></ul></li></ul></li></ul></nav></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-start"><div class="col-md-4 col-sm-12"><h5>联系方式:</h5><ul><li><a href=mailto:chromosomedtime@163.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>chromosomedtime@163.com</span></a></li><li><a href=https://github.com/foreverool target=_blank rel=noopener><span><i class="fab fa-github"></i></span> <span>foreverool</span></a></li></ul></div></div></div><hr><div class=container><div class="row text-start"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu_f8b53e7eb0850e5c.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2026 Copyright.</div><div class="col-md-4 text-end"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div><div id=coffeeButton class="coffee-button animate-float"><img src="https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/29abf2f1909549d9b349623ce2f63c9a~tplv-a9rns2rl98-image.image?rcl=20260110223047F413F4F7E44DE37CA261&amp;rk3s=8e244e95&amp;rrcfp=f06b921b&amp;x-expires=1770647481&amp;x-signature=p4RnGOQT983ibuk06MWrJzNPd%2FQ%3D" alt=请我喝咖啡></div><div id=tipModal class=tip-modal><div class=tip-content><div class=tip-header><h3 class=tip-title>请我喝杯咖啡吧！</h3><span id=closeButton class="close-button text-2xl">&#215;</span></div><div class=payment-methods><div class=payment-item><img src=/images/alipay.jpg alt=支付宝>
<span class=payment-name>支付宝</span></div><div class=payment-item><img src=/images/wechat.png alt=微信支付>
<span class=payment-name>微信支付</span></div></div><p class=tip-thank>感谢您的支持与鼓励！</p></div></div><script>const coffeeButton=document.getElementById("coffeeButton"),tipModal=document.getElementById("tipModal"),closeButton=document.getElementById("closeButton");coffeeButton.addEventListener("click",()=>{tipModal.classList.add("active"),document.body.style.overflow="hidden"});function closeModal(){tipModal.classList.remove("active"),document.body.style.overflow=""}closeButton.addEventListener("click",closeModal),tipModal.addEventListener("click",e=>{e.target===tipModal&&closeModal()}),document.addEventListener("keydown",e=>{e.key==="Escape"&&tipModal.classList.contains("active")&&closeModal()});const paymentItems=document.querySelectorAll(".payment-item");paymentItems.forEach(e=>{e.addEventListener("click",()=>{e.classList.add("scale-95"),setTimeout(()=>{e.classList.remove("scale-95")},150);const t=e.querySelector(".payment-name").textContent;alert(`请使用${t}扫描二维码进行支付，感谢您的支持！`)})})</script><script src=/application.f644193b2970089cf24162fcea2b75231b148c5bfce7eb5907da3a23a5c0ffeb.js integrity="sha256-9kQZOylwCJzyQWL86it1IxsUjFv85+tZB9o6I6XA/+s=" defer></script></body></html>