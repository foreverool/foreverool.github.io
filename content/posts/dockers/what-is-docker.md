---
title: 'What Is Docker'
date: '2026-01-29T19:38:22+08:00'
hero: 
description: ""
theme: Toha
tags:
  - docker
menu:
  sidebar:
    name: 什么是docker
    identifier: what-is-docker
    parent: dockers
    weight: 1
---

# 什么是Docker

在学习`Docker`之前先要了解一下虚拟机和容器。

虚拟机和容器是两种核心的虚拟化技术，核心目标都是实现**资源隔离与环境标准化**，但二者的虚拟化层级、实现原理、资源占用、隔离性天差地别。

- 虚拟机是**硬件级虚拟化**模拟完整的计算机硬件并运行独立的操作系统。
- 容器时**操作系统级虚拟化**，基于宿主主机内核实现进程级隔离，无独立的操作系统。

## 1. 虚拟机



### 1.1 核心定义

​	虚拟机是通过**虚拟化软件**(Hypervisor)在物理宿主主机上模拟出**多套独立的硬件环境**（CPU、内存、磁盘、网卡、主板等），每套硬件环境都能安装独立的操作系统和应用。在不同虚拟机之间完全隔离，彼此感知不到对方的存在，就像一台物理主机运行了多台"独立的电脑"。

  核心架构：

​	虚拟机的虚拟化是硬件层的抽象，架构从下到上分为：

- 物理硬件
- Hypervisor(虚拟化层)
- 多个虚拟机

虚拟机本身不能独立运行，必须依赖Hypervisor--它是虚拟机的管理者，负责硬件资源的抽象、分配、中转，虚拟机的所有操作（启动、运行、资源调用）都由Hypervisor接管。

**Hypervisor**是虚拟机技术的关键，其一般有两种类型：

- 跑在硬件之上的Hypervisor，虚拟机就基于硬件 + Hypervisor运行，无系统依赖。
- 跑在操作系统之上的Hypervisor，虚拟机就基于硬件+操作系统+Hypervisor运行，依赖于宿主主机OS。

第一种类型的Hypervisor一般用于企业端，直接跑在硬件上不需要依赖操作系统，在硬件之上虚拟多个操作系统。

第二种类型的Hypervisor一般是面向于个人，比如`vmware workstation`软件，我们可以在操作系统上安装多个不同的操作系统。

<img src="/images/posts/docker/image-20260128132438989.png" alt="image-20260128132438989" style="zoom:67%;" />

在windows上的`wsl`也是使用的第二种类型的`Hypervisor`。

#### 1.2  优缺点

|                             优点                             |                             缺点                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 🔒 **隔离性极强**：硬件级隔离，虚拟机间无任何资源共享，一个虚拟机故障 / 崩溃不会影响其他虚拟机和宿主机 | ⚡ **资源占用极高**：每个虚拟机都包含完整 OS 和内核，预装大量系统库，镜像体积大，资源预先分配，利用率低 |
| 📌 **OS 无关性**：支持任意异构操作系统（Windows/Linux/macOS），可在 Linux 物理机上运行 Windows 虚拟机，反之亦然 | 🐢 **启动速度慢**：需要完整加载操作系统内核和系统服务，启动时间通常为**分钟级**（如 Windows 虚拟机启动约 1-3 分钟，Linux 约 30 秒 - 1 分钟） |
| 🛡️ **安全性高**：应用运行在独立的 Guest OS 中，即使应用被攻击，也仅局限在虚拟机内部，无法直接渗透到宿主机和其他虚拟机 | 📈 **运维复杂**：每个虚拟机都需要独立维护（更新系统、打补丁、安装依赖），多虚拟机场景下运维成本指数级上升 |
| 🎯 **兼容性好**：支持运行**所有传统应用**（如老旧的单机软件、未做容器化改造的企业级应用），无需修改应用代码 | 🚀 **性能损耗**：Hypervisor 的资源中转存在一定损耗，Type2 型损耗更明显 |

## 2. 容器

​	容器是操作系统级**轻量隔离进程**

​	容器的虚拟化是操作系统层的抽象，并非模拟硬件，而是基于宿主主机的内核，通过Linux内核的原生特性实现进程级的资源隔离和限制，容器本质是**被隔离的、轻量的特殊进程**

**核心定义**

​	容器是在单一宿主机OS内核上，通过**容器运行时**实现进程隔离环境，每个容器仅包含应用程序+运行所需的依赖库/配置（无独立操作系统、无独立内核），共享宿主主机的内核和系统核心库。同时通过内核特性实现资源限制（CPU/内存）和环境隔离（网络/文件系统/进程），不同容器的进程彼此隔离，就像在一个OS上运行了多个独立的应用沙箱。

**核心架构：**

​	容器的虚拟化技术是操作系统内核层的抽象，架构从下到上分为：

- 物理硬件
- 宿主机操作系统
- 容器运行时
- 多个容器

`windwos/macOS`本身没有Linux的容器内核特性，所以相关docker软件（Docker Desktop\Colima）会在本地启动一个轻量级Linux虚拟机，容器实际上运行在这个Linux虚拟机中。

Linux宿主机上的容器无需额外虚拟机，直接基于内核运行，性能损耗很低。

**核心工作原理：**

​	基于Linux内核三大核心特性

容器的隔离和资源限制**完全依赖于Linux内核的原生能力，无需额外虚拟化软件，这是它轻量、高速的底层原因**。

- `Namespaces`命名空间：实现环境隔离

  对容器的**进程、网络、文件系统、主机名、用户**等进行隔离，让每个容器都有【独立的视角】:

  - 容器内的PID1进程，在宿主机上是一个普通的PID如1234，容器内无法查看宿主机和其它容器的进程。
  - 容器内有独立的网卡和IP，与宿主机/其它容器的网络隔离，通过**网桥**实现通信。

- cgroups(控制组):实现资源限制
  对容器CPU、内存、磁盘IO、网络带宽等资源进行精准限制，比如限制某个容器最多使用1核CPU、2G内存，即使宿主机资源充足，容器也不会超额使用，避免单个容器占用全部资源导致其它容器崩溃。

- UnionFS(联合文件系统)：实现镜像分层与轻量化
  这是Docker镜像核心技术，将容器镜像差分多个**只读的分层**，多个容器可以共享相同的分层（如多个python应用共享Python基础镜像层），仅在容器运行时创建唯一的可写层，大幅减少镜像体积和磁盘占用。

**核心组件：**

- 容器镜像： 容器的**只读模板**，包含应用运行所需的代码、依赖库、配置、系统工具，无完整OS和内核，体积为MB级，可通过Dockerfile构建，支持跨平台分发。
- 容器运行时： 负责容器的创建、启动、停止、销毁，是容器与内核的交互层。
- 容器引擎： 为用户提供可视化/命令行操作界面，封装运行时复杂操作。代表：Docker。
- 编排工具：解决多容器的集群管理问题，如容器启动顺序，负载均衡、故障恢复、扩缩容，云原生核心，代表k8s。
- 镜像仓库：用于存储和分发容器镜像，docker hub

**优缺点**

|                             优点                             |                             缺点                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 🚀 **极致轻量**：无独立 OS 和内核，仅包含应用和依赖，镜像体积为 MB 级，远小于虚拟机的 GB 级 | 🔗 **内核依赖**：同一宿主机的所有容器**共享宿主机内核**，无法运行与宿主机内核不兼容的 OS 应用（如 Linux 宿主机无法运行 Windows 原生应用，需通过 WSL / 虚拟机中转） |
| ⚡ **启动速度极快**：无需加载操作系统，仅启动一个特殊进程，启动时间为**毫秒级 / 秒级**（如 Docker 容器启动通常 < 1 秒） | 🛡️ **隔离性弱于 VM**：进程级隔离，基于内核特性实现，若内核存在漏洞，可能导致「容器逃逸」（攻击者突破容器隔离，访问宿主机 / 其他容器），隔离性不如虚拟机的硬件级隔离 |
| 💯 **资源利用率极高**：资源**动态分配**，容器闲置时资源会释放给宿主机，支持超分（物理机 4G 内存可运行数十个轻量容器），性能损耗极低（1%-5%） | 📋 **应用兼容性有限**：要求应用**无状态、可移植**，老旧的「重量级应用」（如依赖特定内核模块、专属驱动的应用）难以容器化，需修改代码适配 |
| 🔄 **环境标准化**：「一次构建，到处运行」，容器镜像在开发、测试、生产环境完全一致，彻底解决「开发环境能跑，生产环境跑不了」的问题 | 🚨 **系统特性受限**：容器内无法修改宿主机内核参数，无法安装与宿主机内核冲突的驱动 / 模块，部分系统级操作被限制 |
| 📦 **易运维 / 易扩展**：容器镜像可版本化、可追溯，支持 CI/CD 流水线无缝集成，结合 K8s 可实现容器的自动化扩缩容、故障自愈，适配 DevOps / 云原生 | 📈 **网络 / 存储复杂度**：容器的动态创建 / 销毁导致网络、存储的管理复杂度升高，需专门的网络插件（如 Calico）、存储插件（如 CSI）支撑 |

### 3. 虚拟机和容器的对比

|      对比维度       |              虚拟机（VM）              |                      容器（Container）                       |
| :-----------------: | :------------------------------------: | :----------------------------------------------------------: |
|   **虚拟化层级**    |         硬件层（物理硬件抽象）         |                  操作系统层（内核资源抽象）                  |
|    **内核归属**     | 每个虚拟机有**独立的内核**（Guest OS） |            所有容器**共享宿主机内核**，无独立内核            |
|  **资源分配方式**   |     预先分配，独占配额，闲置不释放     |             动态分配，按需使用，闲置释放给宿主机             |
|    **启动速度**     |        分钟级（需加载完整 OS）         |                  毫秒 / 秒级（仅启动进程）                   |
| **镜像 / 系统体积** |      GB 级（含完整 OS、内核、库）      |             MB 级（仅含应用 + 依赖，共享基础层）             |
|     **隔离性**      |      硬件级隔离，极强，彼此无感知      |     进程级隔离，较强，基于 Linux 内核特性，存在逃逸风险      |
|    **性能损耗**     |      5%-20%（Type1 低，Type2 高）      |              1%-5%，几乎可忽略（Linux 宿主机）               |
|   **资源利用率**    |        低，资源独占，易闲置浪费        |         极高，支持超分，可运行数十 / 上百个轻量容器          |
|     **OS 支持**     | 支持任意异构 OS（Windows/Linux/macOS） | 仅支持与宿主机内核兼容的 OS，Linux 为主，Windows 需特殊适配  |
|  **核心实现技术**   |   Hypervisor（KVM/ESXi/VirtualBox）    | Linux 内核（Namespaces/cgroups/UnionFS）+ 运行时（containerd/runc） |
|   **运维复杂度**    | 高，每个 VM 独立维护（更新 / 打补丁）  |      低，镜像版本化，一次构建到处运行，集群可自动化编排      |
|    **代表工具**     |   VMware ESXi/KVM/VirtualBox/Hyper-V   |         Docker/containerd/K8s/Docker Compose/Podman          |



## 4. Docker

`docker`是容器的一个具体实现，也是容器生态最好的产品，其主要包含`docker cli`和`docker`引擎，当我们使用`docker`客户端工具执行相关命令时，其会将我们的指令分析之后传递给`docker`引擎并执行。

![image-20260129174328384](/images/posts/docker/image-20260129174328384.png)

`dockers`客户端可以与引擎在统一主机，也可以不在同一个主机下 ，通过网络进行连接。

![image-20260129174529377](/images/posts/docker/image-20260129174529377.png)

上述图片描述了`docker`客户端和引擎部分实现细节。